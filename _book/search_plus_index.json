{"./":{"url":"./","title":"Introduction","keywords":"","body":"目录 0-Flutter Flutter 图片加载 Flutter 应用启动分析 Flutter 混合工程搭建 Flutter混合工程踩坑记录 Flutter 混合工程上传AAR Flutter 引擎启动（1.9） Flutter引擎启动 Redux 介绍 Android-old ArrayList 源码学习 Fragmentation 库学习笔记 HashMap 源码学习笔记 JVM 学习笔记 LinkedList 学习笔记 Okhttp 学习笔记 Retrofit 学习笔记 Set 集合源码 沉浸式状态栏 machine 机器学习笔记-基础 机器学习笔记-autograd自动求导 机器学习笔记-NDArray处理数据 机器学习笔记-Numpy 机器学习笔记-矩阵 机器学习笔记-线性回归 其他 管理conda Git 学习笔记 UML 类图 关于 个人一些文章笔记。 Copyright © david 2019 all right reserved，powered by Gitbook该文件修订时间： 2020-04-28 16:12:57 "},"0-Flutter/1-Flutter图片加载.html":{"url":"0-Flutter/1-Flutter图片加载.html","title":"Flutter 图片加载","keywords":"","body":"Flutter 图片加载 记录分析Flutter 加载图片过程。 使用 在Flutter 中加载图片可Image 控件。除了直接调用构造，Image 提供了4种方式加载，分别是： Image.asset 从AssetBundle 中加载图片，即是在pubspec.yaml中注册的图片。 在pubspec.yaml中注册的图片在打包时候会按照K-V 形式写入 asset/flutter_assets/AssetManifest.json 文件中。 Image.file 从文件中加载。 Image.memory 内存中加载。 Image.network 网络中加载。 分析 以Image.network为例: Image.network( String src, { Key key, double scale = 1.0, .... }) : image = ResizeImage.resizeIfNeeded(cacheWidth, cacheHeight, NetworkImage(src, scale: scale, headers: headers)), assert(alignment != null), assert(repeat != null), assert(matchTextDirection != null), assert(cacheWidth == null || cacheWidth > 0), assert(cacheHeight == null || cacheHeight > 0), super(key: key); 这里image为ImageProvider对象。ImageProvider 是个抽象类，不同的加载方式内部也是创建不同的ImageProvider。 Image Image 是一个StatefulWidget。其中State 为_ImageState。 class _ImageState extends State with WidgetsBindingObserver { ImageStream _imageStream; ImageInfo _imageInfo; ImageChunkEvent _loadingProgress; bool _isListeningToStream = false; bool _invertColors; int _frameNumber; bool _wasSynchronouslyLoaded; @override void initState() { super.initState(); WidgetsBinding.instance.addObserver(this); } @override void dispose() { assert(_imageStream != null); WidgetsBinding.instance.removeObserver(this); _stopListeningToStream(); super.dispose(); } @override void didChangeDependencies() { _updateInvertColors(); _resolveImage(); if (TickerMode.of(context)) _listenToStream(); else _stopListeningToStream(); super.didChangeDependencies(); } .... void _resolveImage() { final ImageStream newStream = widget.image.resolve(createLocalImageConfiguration( context, size: widget.width != null && widget.height != null ? Size(widget.width, widget.height) : null, )); assert(newStream != null); _updateSourceStream(newStream); } @override Widget build(BuildContext context) { ... return result; } .... } 可以看见在didChangeDependencies 方法中会调用_resolveImage方法，这里会进行图片加载操作。而widget.image 就是上面提到的ImageProvider对象。这里是先调用createLocalImageConfiguration方法创建图片的配置信息ImageConfiguration，然后调用ImageProvider的让resolve方法。 ImageProvider.resolve ImageStream resolve(ImageConfiguration configuration) { assert(configuration != null); final ImageStream stream = ImageStream(); T obtainedKey; bool didError = false; Future handleError(dynamic exception, StackTrace stack) async { if (didError) { return; } didError = true; await null; // wait an event turn in case a listener has been added to the image stream. final _ErrorImageCompleter imageCompleter = _ErrorImageCompleter(); stream.setCompleter(imageCompleter); imageCompleter.setError( exception: exception, stack: stack, context: ErrorDescription('while resolving an image'), silent: true, // could be a network error or whatnot informationCollector: () sync* { // 生成迭代器 yield DiagnosticsProperty('Image provider', this); yield DiagnosticsProperty('Image configuration', configuration); yield DiagnosticsProperty('Image key', obtainedKey, defaultValue: null); }, ); } // fork 出一个Zone，添加上面的错误处理 final Zone dangerZone = Zone.current.fork( specification: ZoneSpecification( handleUncaughtError: (Zone zone, ZoneDelegate delegate, Zone parent, Object error, StackTrace stackTrace) { handleError(error, stackTrace); } ) ); dangerZone.runGuarded(() { Future key; try { // 图片配置信息生成Key值，网络图片通过url和缩放比scale 作为key值 key = obtainKey(configuration); } catch (error, stackTrace) { handleError(error, stackTrace); return; } key.then((T key) { obtainedKey = key; // 加载 final ImageStreamCompleter completer = PaintingBinding.instance.imageCache.putIfAbsent( key, () => load(key, PaintingBinding.instance.instantiateImageCodec), onError: handleError, ); if (completer != null) { stream.setCompleter(completer); } }).catchError(handleError); }); return stream; } putIfAbsent 上调用了PaintingBinding.instance.imageCache的putIfAbsent方法，imageCache 是啥？putIfAbsent 方法又做了什么事情。 ImageCache ImageCache 是Framework 层提供的图片缓存存储类，最多缓存1000张图片，最大缓存量为100M。LRU 缓存机制。内部有两个Map，分别存储待处理的图片以及缓存的图片。 putIfAbsent ImageStreamCompleter putIfAbsent(Object key, ImageStreamCompleter loader(), { ImageErrorListener onError }) { assert(key != null); assert(loader != null); ImageStreamCompleter result = _pendingImages[key]?.completer; // 如果图片是待处理中，return if (result != null) return result; // 如果缓存中有，取出，放到前面，返回缓存图片 final _CachedImage image = _cache.remove(key); if (image != null) { _cache[key] = image; return image.completer; } try { // 执行loader 函数，获取结果 result = loader(); } catch (error, stackTrace) { if (onError != null) { onError(error, stackTrace); return null; } else { // 继续传播异常 rethrow; } } void listener(ImageInfo info, bool syncCall) { // Images that fail to load don't contribute to cache size. final int imageSize = info?.image == null ? 0 : info.image.height * info.image.width * 4; final _CachedImage image = _CachedImage(result, imageSize); // 调整最大size if (maximumSizeBytes > 0 && imageSize > maximumSizeBytes) { _maximumSizeBytes = imageSize + 1000; } _currentSizeBytes += imageSize; final _PendingImage pendingImage = _pendingImages.remove(key); if (pendingImage != null) { pendingImage.removeListener(); } _cache[key] = image; _checkCacheSize(); } // 回调监听 if (maximumSize > 0 && maximumSizeBytes > 0) { final ImageStreamListener streamListener = ImageStreamListener(listener); _pendingImages[key] = _PendingImage(result, streamListener); // Listener is removed in [_PendingImage.removeListener]. result.addListener(streamListener); } return result; } loader () => load(key, PaintingBinding.instance.instantiateImageCodec) load方法是抽象方法，不同ImageProvider 有不同的实现，这里以NetImage为例： ImageStreamCompleter load(image_provider.NetworkImage key, image_provider.DecoderCallback decode) { // Ownership of this controller is handed off to [_loadAsync]; it is that // method's responsibility to close the controller's stream when the image // has been loaded or an error is thrown. final StreamController chunkEvents = StreamController(); return MultiFrameImageStreamCompleter( codec: _loadAsync(key, chunkEvents, decode), chunkEvents: chunkEvents.stream, scale: key.scale, informationCollector: () { return [ DiagnosticsProperty('Image provider', this), DiagnosticsProperty('Image key', key), ]; }, ); } 这里返回的是一个ImageStreamCompleter的子类MultiFrameImageStreamCompleter对象，而ImageStreamCompleter是个抽象类，里面是一些图片加载过程的接口，可用来监听图片加载的状态。 MultiFrameImageStreamCompleter({ @required Future codec, @required double scale, Stream chunkEvents, InformationCollector informationCollector, }) : assert(codec != null), _informationCollector = informationCollector, _scale = scale { codec.then(_handleCodecReady, onError: (dynamic error, StackTrace stack) { reportError( context: ErrorDescription('resolving an image codec'), exception: error, stack: stack, informationCollector: informationCollector, silent: true, ); }); .... } 创建MultiFrameImageStreamCompleter中会执行codec 函数，而codec 是个Future函数，即是前面的 _loadAsync _loadAsync Future _loadAsync( NetworkImage key, StreamController chunkEvents, image_provider.DecoderCallback decode, ) async { try { assert(key == this); // 解析图片地址 final Uri resolved = Uri.base.resolve(key.url); // 构建请求 final HttpClientRequest request = await _httpClient.getUrl(resolved); // 请求头不为空话添加请求头 headers?.forEach((String name, String value) { request.headers.add(name, value); }); //解析获取响应 final HttpClientResponse response = await request.close(); // 响应失败处理 if (response.statusCode != HttpStatus.ok) throw image_provider.NetworkImageLoadException(statusCode: response.statusCode, uri: resolved); // 响应转为字节数组 final Uint8List bytes = await consolidateHttpClientResponseBytes( response, onBytesReceived: (int cumulative, int total) { chunkEvents.add(ImageChunkEvent( cumulativeBytesLoaded: cumulative, expectedTotalBytes: total, )); }, ); if (bytes.lengthInBytes == 0) throw Exception('NetworkImage is an empty file: $resolved'); // 解码图片返回 return decode(bytes); } finally { chunkEvents.close(); } } decode 上面的decode 对象是PaintingBinding.instance.instantiateImageCodec（在ImageProvider 的resolve方法内赋值传入）, Future instantiateImageCodec(Uint8List bytes, { int cacheWidth, int cacheHeight, }) { assert(cacheWidth == null || cacheWidth > 0); assert(cacheHeight == null || cacheHeight > 0); return ui.instantiateImageCodec( bytes, targetWidth: cacheWidth, targetHeight: cacheHeight, ); } 这里调用painting.dart 下的instantiateImageCodec函数 Future instantiateImageCodec(Uint8List list, { int targetWidth, int targetHeight, }) { return _futurize( (_Callback callback) => _instantiateImageCodec(list, callback, null, targetWidth ?? _kDoNotResizeDimension, targetHeight ?? _kDoNotResizeDimension) ); } _futurize _futurize这个函数式把一个回调函数包装成Future函数。 Future _futurize(_Callbacker callbacker) { final Completer completer = Completer.sync(); final String error = callbacker((T t) { if (t == null) { completer.completeError(Exception('operation failed')); } else { completer.complete(t); } }); if (error != null) throw Exception(error); return completer.future; } 这里是通过构建Complete对象来把回调函数包装成future，与直接创建Future不同是，Complete可手动控制结束Future。 _instantiateImageCodec String _instantiateImageCodec(Uint8List list, _Callback callback, _ImageInfo imageInfo, int targetWidth, int targetHeight) native 'instantiateImageCodec'; 所以解码的任务交给native 去实现。 _handleCodecReady 在图片下载解码后进行渲染工作。这个方法定义在MultiFrameImageStreamCompleter， codec.then(_handleCodecReady, onError: ...); 在解码图片完成后调用_handleCodecReady。 void _handleCodecReady(ui.Codec codec) { _codec = codec; assert(_codec != null); if (hasListeners) { _decodeNextFrameAndSchedule(); } } 而在Image Widget 的_updateSourceStream方法中会添加监听器，所以hasListeners 为true。 _decodeNextFrameAndSchedule Future _decodeNextFrameAndSchedule() async { try { //获取下一帧 _nextFrame = await _codec.getNextFrame(); } catch (exception, stack) { reportError( context: ErrorDescription('resolving an image frame'), exception: exception, stack: stack, informationCollector: _informationCollector, silent: true, ); return; } // 如果图片只有一帧（非动图） if (_codec.frameCount == 1) { // 非动图处理 _emitFrame(ImageInfo(image: _nextFrame.image, scale: _scale)); return; } // 动图处理 _scheduleAppFrame(); } 这里是获取图片下一帧，进行动图或者非动图处理 _emitFrame void _emitFrame(ImageInfo imageInfo) { setImage(imageInfo); _framesEmitted += 1; } void setImage(ImageInfo image) { _currentImage = image; if (_listeners.isEmpty) return; // 创建监听器集合副本，防止并发修改。 final List localListeners = List.from(_listeners); for (ImageStreamListener listener in localListeners) { try { // 调用监听器onImage方法 listener.onImage(image, false); } catch (exception, stack) { reportError( context: ErrorDescription('by an image listener'), exception: exception, stack: stack, ); } } } 这里的逻辑是取出监听器，并且调用onImage方法。而监听器是： ImageStreamListener _getListener([ImageLoadingBuilder loadingBuilder]) { loadingBuilder ??= widget.loadingBuilder; return ImageStreamListener( _handleImageFrame, onChunk: loadingBuilder == null ? null : _handleImageChunk, ); } 而onImage方法就是_handleImageFrame void _handleImageFrame(ImageInfo imageInfo, bool synchronousCall) { setState(() { _imageInfo = imageInfo; _loadingProgress = null; _frameNumber = _frameNumber == null ? 0 : _frameNumber + 1; _wasSynchronouslyLoaded |= synchronousCall; }); } 这里是调用setState 来刷新Widget界面。 _scheduleAppFrame void _scheduleAppFrame() { if (_frameCallbackScheduled) { return; } _frameCallbackScheduled = true; //注册下一帧的回调 SchedulerBinding.instance.scheduleFrameCallback(_handleAppFrame); } scheduleFrameCallback （binding.dart） int scheduleFrameCallback(FrameCallback callback, { bool rescheduling = false }) { scheduleFrame(); _nextFrameCallbackId += 1; //callback 添加到_transientCallbacks中 _transientCallbacks[_nextFrameCallbackId] = _FrameCallbackEntry(callback, rescheduling: rescheduling); return _nextFrameCallbackId; } 这里调用了scheduleFrame，而scheduleFrame内调用window.scheduleFrame(); 来注册Vsync 信号回调。在Engine收到Vsync 信号后会调用onBeginFrame 以及onDrawFrame 方法，而在binding里会执行handleBeginFrame方法。 void handleBeginFrame(Duration rawTimeStamp) { Timeline.startSync('Frame', arguments: timelineWhitelistArguments); _firstRawTimeStampInEpoch ??= rawTimeStamp; _currentFrameTimeStamp = _adjustForEpoch(rawTimeStamp ?? _lastRawTimeStamp); if (rawTimeStamp != null) _lastRawTimeStamp = rawTimeStamp; ... _hasScheduledFrame = false; try { // TRANSIENT FRAME CALLBACKS Timeline.startSync('Animate', arguments: timelineWhitelistArguments); _schedulerPhase = SchedulerPhase.transientCallbacks; // 获取_transientCallbacks final Map callbacks = _transientCallbacks; //_transientCallbacks置空 _transientCallbacks = {}; callbacks.forEach((int id, _FrameCallbackEntry callbackEntry) { if (!_removedIds.contains(id)) //调用callback _invokeFrameCallback(callbackEntry.callback, _currentFrameTimeStamp, callbackEntry.debugStack); }); _removedIds.clear(); } finally { _schedulerPhase = SchedulerPhase.midFrameMicrotasks; } } _handleAppFrame 上面分析了下一帧信号来的的时候会执行_handAppFrame回调。 （image_stream.dart/MultiFrameImageStreamCompleter） void _handleAppFrame(Duration timestamp) { _frameCallbackScheduled = false; // 没有监听return if (!hasListeners) return; // 如果是第一帧，或者超过某一帧维持时间 if (_isFirstFrame() || _hasFrameDurationPassed(timestamp)) { // 插入一帧 _emitFrame(ImageInfo(image: _nextFrame.image, scale: _scale)); // 更新当前帧显示时间 _shownTimestamp = timestamp; // 更新当前帧持续时间 _frameDuration = _nextFrame.duration; _nextFrame = null; // 判断需要重复执行 final int completedCycles = _framesEmitted ~/ _codec.frameCount; if (_codec.repetitionCount == -1 || completedCycles 这里对于动图，核心逻辑是对于需要重绘的帧调用_emitFrame去刷新。如果是第一帧或者超过当前帧的维持时间，调用 _emitFrame 方法显示一帧图片，否则计算下一帧的间隔时间，执行定时任务再次调用 _scheduleAppFrame方法。所以动图本质也是一帧一帧去显示。 Copyright © david 2019 all right reserved，powered by Gitbook该文件修订时间： 2020-04-28 15:21:18 "},"0-Flutter/2-Flutter 应用启动分析.html":{"url":"0-Flutter/2-Flutter 应用启动分析.html","title":"Flutter 应用启动分析","keywords":"","body":"Flutter 应用启动分析 dart 虚拟机启动时候调用默认的入口函数main，而通常我们调用runApp来启动我们的flutter 应用。而里面又做了什么事情呢？怎么关联我们的Widget？ 流程 1. runApp void runApp(Widget app) { WidgetsFlutterBinding.ensureInitialized() ..scheduleAttachRootWidget(app) ..scheduleWarmUpFrame(); } 1.1 ensureInitialized class WidgetsFlutterBinding extends BindingBase with GestureBinding, ServicesBinding, SchedulerBinding, PaintingBinding, SemanticsBinding, RendererBinding, WidgetsBinding { static WidgetsBinding ensureInitialized() { if (WidgetsBinding.instance == null) WidgetsFlutterBinding(); return WidgetsBinding.instance; } } 这里WidgetFlutterBinding类with 了很多类。 BindingBase 抽象基类 GestureBinding 手势绑定类 ServicesBinding 平台服务绑定类 SchedulerBinding 调度帧绘制绑定类 PaintingBinding 绘制绑定类 SemanticsBinding 语义绑定类 RendererBinding 渲染绑定类 WidgetsBinding widget组件绑定类 scheduleAttachRootWidget 调用： ---WidgetsBinding::scheduleAttachRootWidget ​ ---WidgetsBinding::attachRootWidget ​ ---RenderObjectToWidgetAdapter::attachToRenderTree ​ ---RenderObjectToWidgetAdapter::createElement ​ ---RenderObjectToWidgetElement::mout(null,null) ​ ---RootRenderObjectElement::mount ​ ---RenderObjectElement::mount ​ ---Element::mount ​ --- RenderObjectToWidgetElement::_rebuild ​ ---Element::updateChild ​ ---Element::inflateWidget ​ ---newWidget.createElement(); MyApp ​ ---Element::mout 根Element RenderObjectToWidgetElement直接用了自身持有的根WidgetRenderObjectToWidgetAdapter持有的child来关联了我们传入的MyApp作为子Widget 建立Element树最重要的操作就是Element.mount。 每一种具体类型的Element，实现了如何将当前Element挂接(mount)到父节点上的操作；这个挂接操作除了与父Element建立指向关系外，还规定了当前Element的一些其它属性的创建时机和操作。 创建一个Element最重要的操作就是Element.updateChild。 更具体的是Element.inflateWidget方法；通过创建子Widget方式的不同，区分了两大类Element和Widget: (StatelessElement, StatelessWidget)和(StatefulElement, StatefulWidget) 所谓的Element树更像是前向单链表网，单链表有共同的表头。 父类Element不持有Element子节点，而是通过Element.visitChildren把遍历操作交给具体的Element子类型来实现。 但是RenderObject却像普通的单链表，因为通过mixin RenderObjectWithChildMixin提供的child, RenderObject能够直接遍历子节点。 Copyright © david 2019 all right reserved，powered by Gitbook该文件修订时间： 2020-04-28 15:22:20 "},"0-Flutter/3-Flutter 混合工程.html":{"url":"0-Flutter/3-Flutter 混合工程.html","title":"Flutter 混合工程搭建","keywords":"","body":"Flutter 混合工程搭建 背景 现有的原生移动项目(Android ，IOS)中引入flutter ? 在官方预览指导Add Flutter to existing apps 中 提供了两种引入方式。 方案 flutter module 与flutter app 不同，通常它是以模块形式嵌入原生的app 中，通过以下命令创建： flutter create - t module 模块名 而在IDE 中更可以看见flutter module 与flutter app 的区别。 flutter module 的目录结构 ➜ flutter_module git:(master) ✗ tree -L 2 -a . ├── .android │ ├── Flutter │ ├── app │ ├── ... ├── .gitignore ├── .ios │ ├── Config │ ├── Flutter │ ├── ... │ └── Runner.xcworkspace ├── lib │ └── main.dart ├── pubspec.lock ├── pubspec.yaml └── test └── widget_test.dart 与直接创建flutter项目不同的是，在.android 与.ios 下有个flutter 目录。而这个目录可以生成aar 、framework 库。 依赖源码 是指Android 和 IOS 的项目工程中直接依赖flutter module 工程源码。 步骤 Android 项目下创建flutter 模块 修改setting.gradle文件 // MyApp/settings.gradle include ':app' // assumed existing content setBinding(new Binding([gradle: this])) // new evaluate(new File( // new settingsDir.parentFile, // new 'my_flutter/.android/include_flutter.groovy' // new )) 修改build.gradle 文件 dependencies { implementation project(':flutter') } iOS 原生项目引入flutter module podfile 添加podhelper.rb Xcode的build phases 添加xcode_backend.sh 编译脚本。 协同开发 协同开发中原生使用git submodule 管理. 具体步骤如下： a. 原生项目中添加子模块 git submodule add {flutter module 仓库地址} git submodule update b. 生成.android 和.ios cd 到flutter module 模块内，执行flutter packages get 命令 c. 运行。 依赖产物 这个方案是指原生工程依赖flutter module 编译后产物。在Android 中依赖aar ，而在iOS 中依赖 .framework 内容。 这种方式使原生与flutter的耦合更低。 步骤 其实无论是Android 还是iOS平台，使用产物依赖的方式进行flutter混合开发，一般是经过下面3个步骤。这里以Android 为例。 编译产物 在flutter模块内执行命令flutter build aar，生成aar 包。路径如下： build/host/outputs/repo └── com └── example └── my_flutter └── flutter_release ├── 1.0 │ ├── flutter_release-1.0.aar │ ├── flutter_release-1.0.aar.md5 │ ├── flutter_release-1.0.aar.sha1 │ ├── flutter_release-1.0.pom │ ├── flutter_release-1.0.pom.md5 │ └── flutter_release-1.0.pom.sha1 ├── maven-metadata.xml ├── maven-metadata.xml.md5 └── maven-metadata.xml.sha1 上传远端 可通过相关脚本上传至依赖仓库。Android 中可通过Nexus 搭建maven 私有库。flutter module 工程可通过可持续集成工具发布release 版本的arr包至maven 私有库，而原生这边可以添加远程私有库进行依赖。 原生依赖 这里简单介绍下Android 中远程依赖配置。 项目下的build.gradle 文件： allprojects { repositories { ... maven { url \"远程仓库地址\" // 配置用户名和密码 credentials { username = \"用户名\" password = \"密码\" } } } } app下的build.gradle文件 implementation 'group name:modulelibrary name:版本@aar' 比对 下面在难易度，侵入性，可维护性，调试角度进行两个方案的比对。 难易度 依赖源码显然比依赖产物简单多了。对于依赖产物，还需要进行远程依赖仓库搭建以及上传脚本等一些工作。 侵入性 在对原生工程的侵入性考虑，依赖源码对原生的侵入性较大。而依赖产物方式相当于把flutter module 作为一个组件接入原生工程。 维护性 对于flutter module 来看，两个方案下，它都是作为一个独立的工程，所以维护是一样的。而对于原生工程来说。依赖产物的混合工程更好维护，而依赖源码的工程还需要小心对待git submodule。 调试 对于需要联合调试来说，依赖源码的方式更方便一点。在纯flutter 工程，直接点击热重载flutter 页面机会刷新，而在混合工程中却不行，若想实现热重载，源码依赖的混合工程也很简单。 运行原生工程。 命令行进入flutter module 工程。 输入命令：flutter attach 但依赖源码方式却会导致原生工程编译时间增加。 综上之可得，对于flutter 模块与原生耦合较低的混合工程适用依赖产物方式，而若flutter 模块与原生工程存在较大耦合，则源码依赖的方式更好一些。 方案 难易 侵入 维护 调试 依赖源码 简单 侵入性大 维护较难 调试简单 依赖产物 难 侵入小 维护简单 调试难 问题 各个成员flutter 版本不一致 多人开发过程中无法保证所有成员的flutter SDK版本一致，若各个flutter SDK 版本不一致可能会造成dart api 兼容 以及 dart 虚拟机不一致等问题。解决办法：各个成员使用同个版本SDK，或者参考flutterw解决方案。 growingIO 等第三方统计工具 一些第三方埋点统计工具暂不支持flutter ，所以在选择用flutter实现的页面 需要和产品方面确认。 启动Flutter 白屏 在AOT 模式下情况会好一点，可仿照闲鱼添加loading 对话框。 loading.show() super.onCreate(savedInstanceState) val route =\"route\" val flutterView = Flutter.createView(this, lifecycle, route) flutterView.addFirstFrameListener { loading.dismiss() } Copyright © david 2019 all right reserved，powered by Gitbook该文件修订时间： 2020-04-28 15:23:19 "},"0-Flutter/4-Flutter 混合工程踩坑记录.html":{"url":"0-Flutter/4-Flutter 混合工程踩坑记录.html","title":"Flutter混合工程踩坑记录","keywords":"","body":"Flutter混合工程踩坑记录 背景 前几天把flutter 从1.9.1 升级到最新的1.12.13，其中碰到了一些坑。这里进行整理下。 1. CachedNetworkImageProvider 升级后在编译时出现下面的错误。 The method 'CachedNetworkImageProvider.load' has fewer positional arguments than those of overridden method 'ImageProvider.load' 这是flutter 在1.10.15后对ImageProvider.load进行api更改，而使用的第三方框架cached_network_image里面依赖的是旧的api ，为了适配新的api 使用cached_network_image 2.0.0-rc版本。 2. 集成方式 一般flutter 混合App 集成方式有两种，一种是依赖源码，另外一种是依赖产物。而为了减少对原生工程的侵入，这边采用依赖产物的形式。而在Android 这边，flutter 模块可以通过flutter build aar命令编译成aar 包。 升级后我编译后的aar 依旧放入lib 目录下，一编译，之前的Flutter,FlutterView类全没了。 查看编译后的aar后发现，新版本没有把之前的flutter 相关类以及so库编译进去。 ，而这里只有GeneratedPluginRegistrant类了。 源码依赖下flutter.gradle 添加依赖 而源码依赖下也是只有GeneratedPluginRegistrant类确能够编译通过，为了搞清编译时候他帮我们做了什么，我们来查看下它的gradle 文件。先看下若使用源码依赖时候的flutter gradle 文件。 (.android/Flutter/build.gradle) // Generated file. Do not edit. def localProperties = new Properties() def localPropertiesFile = new File(buildscript.sourceFile.parentFile.parentFile, 'local.properties') if (localPropertiesFile.exists()) { localPropertiesFile.withReader('UTF-8') { reader -> localProperties.load(reader) } } def flutterRoot = localProperties.getProperty('flutter.sdk') if (flutterRoot == null) { throw new GradleException(\"Flutter SDK not found. Define location with flutter.sdk in the local.properties file.\") } def flutterVersionCode = localProperties.getProperty('flutter.versionCode') if (flutterVersionCode == null) { flutterVersionCode = '1' } def flutterVersionName = localProperties.getProperty('flutter.versionName') if (flutterVersionName == null) { flutterVersionName = '1.0' } apply plugin: 'com.android.library' apply from: \"$flutterRoot/packages/flutter_tools/gradle/flutter.gradle\" group '................' version '1.0' android { compileSdkVersion 28 defaultConfig { minSdkVersion 16 targetSdkVersion 28 versionCode flutterVersionCode.toInteger() versionName flutterVersionName testInstrumentationRunner \"androidx.test.runner.AndroidJUnitRunner\" } } flutter { source '../..' } dependencies { testImplementation 'junit:junit:4.12' } 这里依赖了sdk 中的flutter.gradle文件，这里可以看见它定义了FlutterPlugin插件，在它apply函数下 ..... project.android.buildTypes.each this.&addFlutterDependencies project.android.buildTypes.whenObjectAdded this.&addFlutterDependencies 进行依赖添加， void addFlutterDependencies(buildType) { String flutterBuildMode = buildModeFor(buildType) if (!supportsBuildMode(flutterBuildMode)) { return } String repository = useLocalEngine() ? project.property('local-engine-repo') : MAVEN_REPO project.rootProject.allprojects { repositories { maven { url repository } } } // Add the embedding dependency. addApiDependencies(project, buildType.name, \"io.flutter:flutter_embedding_$flutterBuildMode:$engineVersion\") List platforms = getTargetPlatforms().collect() // Debug mode includes x86 and x64, which are commonly used in emulators. if (flutterBuildMode == \"debug\" && !useLocalEngine()) { platforms.add(\"android-x86\") platforms.add(\"android-x64\") } platforms.each { platform -> String arch = PLATFORM_ARCH_MAP[platform].replace(\"-\", \"_\") // Add the `libflutter.so` dependency. addApiDependencies(project, buildType.name, \"io.flutter:${arch}_$flutterBuildMode:$engineVersion\") } } 这里主要添加了embedding 以及libflutter.so 依赖。 产物依赖下添加相关依赖 产物依赖模式下是怎么处理那些依赖的呢。我们在回到flutter build aar 命令下，执行后， 新版本会提示我们集成步骤。 和之前版本有两个主要不同点： 添加flutter io 远程仓库 maven { url 'http://download.flutter.io' } 依赖项减少 之前版本若flutter module 依赖其他第三方包，集成时候需要加上第三方的aar 文件，而现在只需要什么依赖flutter module 模块。 原因是，执行命令后生成一个本地maven仓库，而其他第三方依赖生命在flutter module 的pom文件中。 来看下其中debug 版本下的pom文件 4.0.0 flutter模块名 flutter_debug 1.0 aar io.flutter flutter_embedding_debug 1.0.0-2994f7e1e682039464cb25e31a78b86a3c59b695 compile io.flutter armeabi_v7a_debug 1.0.0-2994f7e1e682039464cb25e31a78b86a3c59b695 compile io.flutter arm64_v8a_debug 1.0.0-2994f7e1e682039464cb25e31a78b86a3c59b695 compile io.flutter x86_64_debug 1.0.0-2994f7e1e682039464cb25e31a78b86a3c59b695 compile io.flutter x86_debug 1.0.0-2994f7e1e682039464cb25e31a78b86a3c59b695 compile io.github.ponnamkarthik.toast.fluttertoast fluttertoast_debug 1.0 compile io.flutter.plugins.sharedpreferences shared_preferences_debug 1.0 compile io.flutter.plugins.shared_preferences_web shared_preferences_web_debug 1.0 compile io.flutter.plugins.shared_preferences_macos shared_preferences_macos_debug 1.0 compile com.tekartik.sqflite sqflite_debug 1.0 compile io.flutter.plugins.pathprovider path_provider_debug 1.0 compile 看见其中主要有之前的embedding ，libflutter.so 以及第三方依赖项。 而实际开发中我们可以把这些文件上传到maven私有库。并把这些flutter配置项声明在一个gradle 文件中。然后在app 模块中apply即可。 3. Android 集成 升级后相关api 也进行了更改。 原本集成 FlutterView flutterView = Flutter.createView(this, this.getLifecycle(), routeName); setContentView(flutterView); 通过Flutter 工具类创建出flutterview 然后设置成Activity 的contentview。 现集成 升级后你会发现Flutter 这个类不见了。现在官方的集成步骤如下： 清单文件中添加FlutterActivity 启动flutterActivity 正常启动 myButton.setOnClickListener { startActivity( FlutterActivity.createDefaultIntent(this) ) } 或者指定路由,使用新的flutter engine myButton.setOnClickListener { startActivity( FlutterActivity .withNewEngine() .initialRoute(\"/my_route\") .build(this) ) } 使用缓存 在Application 中预先创建flutter engine class MyApplication : Application() { lateinit var flutterEngine : FlutterEngine override fun onCreate() { super.onCreate() // Instantiate a FlutterEngine. flutterEngine = FlutterEngine(this) // Start executing Dart code to pre-warm the FlutterEngine. flutterEngine.dartExecutor.executeDartEntrypoint( DartExecutor.DartEntrypoint.createDefault() ) // Cache the FlutterEngine to be used by FlutterActivity. FlutterEngineCache .getInstance() .put(\"my_engine_id\", flutterEngine) } } 使用缓存 myButton.setOnClickListener { startActivity( FlutterActivity .withCachedEngine(\"my_engine_id\") .build(this) ) } 查看flutterActivity 源码我们发现，其实里面是通过intent 来指定cache ，route 等参数。要注意的是使用了cache engine 就不能指定initRoute 。来看下flutterActivity 帮我们做了什么。 FlutterActivity 源码 1.Activity 的 onCreate 方法 @Override protected void onCreate(@Nullable Bundle savedInstanceState) { // 配置主题 switchLaunchThemeForNormalTheme(); super.onCreate(savedInstanceState); lifecycle.handleLifecycleEvent(Lifecycle.Event.ON_CREATE); // 创建代理 delegate = new FlutterActivityAndFragmentDelegate(this); delegate.onAttach(this); delegate.onActivityCreated(savedInstanceState); // 配置backgroundMode configureWindowForTransparency(); // 设置content view setContentView(createFlutterView()); // 配置状态栏，这里配置的颜色为0x40000000 configureStatusBarForFullscreenFlutterExperience(); } 其中主要任务是： 创建FlutterActivityAndFragmentDelegate对象，执行onAttach，onActivityCreated方法。 设置contentView。 2. FlutterActivityAndFragmentDelegate FlutterActivityAndFragmentDelegate主要是FlutterActivity 以及FlutterFragment 的代理类。 2.1 onAttach方法 void onAttach(@NonNull Context context) { ensureAlive(); if (flutterEngine == null) { // 创建flutter engine setupFlutterEngine(); } //创建platformPlugin platformPlugin = host.providePlatformPlugin(host.getActivity(), flutterEngine); if (host.shouldAttachEngineToActivity()) { Log.d(TAG, \"Attaching FlutterEngine to the Activity that owns this Fragment.\"); flutterEngine.getActivityControlSurface().attachToActivity( host.getActivity(), host.getLifecycle() ); } //配置flutter engine host.configureFlutterEngine(flutterEngine); } ​ 这里主要是创建flutter engine 以及 PlatformPlugin对象。 2.2 setupFlutterEngine void setupFlutterEngine() { Log.d(TAG, \"Setting up FlutterEngine.\"); String cachedEngineId = host.getCachedEngineId(); if (cachedEngineId != null) { flutterEngine = FlutterEngineCache.getInstance().get(cachedEngineId); isFlutterEngineFromHost = true; if (flutterEngine == null) { throw new IllegalStateException(\"The requested cached FlutterEngine did not exist in the FlutterEngineCache: '\" + cachedEngineId + \"'\"); } return; } flutterEngine = host.provideFlutterEngine(host.getContext()); if (flutterEngine != null) { isFlutterEngineFromHost = true; return; } Log.d(TAG, \"No preferred FlutterEngine was provided. Creating a new FlutterEngine for\" + \" this FlutterFragment.\"); flutterEngine = new FlutterEngine(host.getContext(), host.getFlutterShellArgs().toArray()); isFlutterEngineFromHost = false; } 这里创建flutter engine 有3段逻辑： 如果设置了cache engine id 则从cache engine 中获取。 如果host （也就是Activity 或者fragment ）提供了engine 则使用。 直接创建FlutterEngine。 3. createFlutterView() 这里主要是调用Delegate 的onCreateView方法。 View onCreateView(LayoutInflater inflater, @Nullable ViewGroup container, @Nullable Bundle savedInstanceState) { Log.v(TAG, \"Creating FlutterView.\"); ensureAlive(); //创建flutterView flutterView = new FlutterView(host.getActivity(), host.getRenderMode(), host.getTransparencyMode()); // 设置显示渲染监听 flutterView.addOnFirstFrameRenderedListener(flutterUiDisplayListener); // 创建flutterSplashView flutterSplashView = new FlutterSplashView(host.getContext()); if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.JELLY_BEAN_MR1) { flutterSplashView.setId(View.generateViewId()); } else { flutterSplashView.setId(486947586); } //flutterSplashView 与flutterview 关联 flutterSplashView.displayFlutterViewWithSplash(flutterView, host.provideSplashScreen()); return flutterSplashView; } 这里主要是： 创建flutterview 设置显示监听 创建fluttersplashView 可以看见设置到Activity 中的view 不是flutter ，而是flutterSplashView。而flutterSplashView 是一个FrameLayout帧布局。而这个主要是解决flutter 启动白屏/黑屏问题。在启动flutter到渲染过程中，可能会出现黑屏或者白屏问题。而之前的解决方案一般是先显示个loading，然后在flutter 显示后的监听回调中隐藏这个loading 。 而在新版本中可以配置个SplashScreen进行显示。查看FlutterSplashView的displayFlutterViewWithSplash方法，其实内部也是通过flutterview的FirstFrameRenderedListener监听来控制flutterview 与splashview 显示与隐藏。 onStart方法 FlutterActivity的onstart 方法主要交给Delegate去做。我们直接看下代理的onstart 方法。 void onStart() { Log.v(TAG, \"onStart()\"); ensureAlive(); // We post() the code that attaches the FlutterEngine to our FlutterView because there is // some kind of blocking logic on the native side when the surface is connected. That lag // causes launching Activitys to wait a second or two before launching. By post()'ing this // behavior we are able to move this blocking logic to after the Activity's launch. // TODO(mattcarroll): figure out how to avoid blocking the MAIN thread when connecting a surface new Handler().post(new Runnable() { @Override public void run() { Log.v(TAG, \"Attaching FlutterEngine to FlutterView.\"); flutterView.attachToFlutterEngine(flutterEngine); doInitialFlutterViewRun(); } }); } 这里主要： flutterview 关联flutterengine。 调用doInitialFlutterViewRun初始化。 而上述操作为了避免阻塞onstart 方法，放置在Handler中进行操作。 4.doInitialFlutterViewRun private void doInitialFlutterViewRun() { // 如果使用cache engine return（所以设置route id 不起作用） if (host.getCachedEngineId() != null) { return; } if (flutterEngine.getDartExecutor().isExecutingDart()) { // No warning is logged because this situation will happen on every config // change if the developer does not choose to retain the Fragment instance. // So this is expected behavior in many cases. return; } Log.d(TAG, \"Executing Dart entrypoint: \" + host.getDartEntrypointFunctionName() + \", and sending initial route: \" + host.getInitialRoute()); // The engine needs to receive the Flutter app's initial route before executing any // Dart code to ensure that the initial route arrives in time to be applied. if (host.getInitialRoute() != null) { //初始化route 路径 flutterEngine.getNavigationChannel().setInitialRoute(host.getInitialRoute()); } // Configure the Dart entrypoint and execute it. // 执行入口函数，默认为main DartExecutor.DartEntrypoint entrypoint = new DartExecutor.DartEntrypoint( host.getAppBundlePath(), host.getDartEntrypointFunctionName() ); flutterEngine.getDartExecutor().executeDartEntrypoint(entrypoint); } 这里我们可以看见如果我们使用cache engine ，engine 预先创建后，无法指定route 路径。 4.实际集成。 实际开发中我们一般自己创建flutterActivity ，主要是可以添加methodchannel 进行flutter 与原生交互。主要矛盾是，若设置了cache id 无法指定route 路径。解决方法是，可以创建一个routeMethodChannel 进行交互指定跳转路径。 Copyright © david 2019 all right reserved，powered by Gitbook该文件修订时间： 2020-04-28 15:28:48 "},"0-Flutter/5-Flutter 混合工程上传AAR.html":{"url":"0-Flutter/5-Flutter 混合工程上传AAR.html","title":"Flutter 混合工程上传AAR","keywords":"","body":"Flutter 混合工程上传AAR 背景 Copyright © david 2019 all right reserved，powered by Gitbook该文件修订时间： 2020-04-28 15:29:15 "},"0-Flutter/6-Flutter 引擎启动v1-9.html":{"url":"0-Flutter/6-Flutter 引擎启动v1-9.html","title":"Flutter 引擎启动（1.9）","keywords":"","body":"Flutter 引擎启动（1.9） 前言 接触过Flutter也有大半年了，一直很好奇它是怎么在Android中启动执行的。经过一个礼拜的学习，渐渐摸清其主要分3个步骤。 FlutterApplication 启动。 FlutterActivity启动。 Flutter Engine 启动。 （本文分析基于Flutter 1.9 源码） FlutterApplication 启动 进行过Android 开发的同学都知道，App启动会经过Application 以及 Activity 的初始化。这里我们先看下FlutterApplication 做了什么事情。 1. FlutterApplication.onCreate @Override @CallSuper public void onCreate() { super.onCreate(); FlutterMain.startInitialization(this); } 可以看到这个类其实也没有做很多事，就是执行了FlutterMain.startInitialization方法。 2. FlutterMain.startInitialization public static void startInitialization(@NonNull Context applicationContext) { // Do nothing if we're running this in a Robolectric test. if (isRunningInRobolectricTest) { return; } startInitialization(applicationContext, new Settings()); } 这里创建了一个Setting对象，然后调用重载方法startInitialization。 public static void startInitialization(@NonNull Context applicationContext, @NonNull Settings settings) { ... // 确保运行在主线程 if (Looper.myLooper() != Looper.getMainLooper()) { throw new IllegalStateException(\"startInitialization must be called on the main thread\"); } // Do not run startInitialization more than once. if (sSettings != null) { return; } sSettings = settings; // 记录启动时长 long initStartTimestampMillis = SystemClock.uptimeMillis(); // 执行3 initConfig方法 initConfig(applicationContext); // 初始化资源 initResources(applicationContext); // 加载flutter so库 System.loadLibrary(\"flutter\"); ... long initTimeMillis = SystemClock.uptimeMillis() - initStartTimestampMillis; //记录启动时长 FlutterJNI.nativeRecordStartTimestamp(initTimeMillis); } 可以看见这个方法其实主要做了4件事： 执行initConfig 方法，进行配置初始化。 初始化资源。 加载flutter so库。 记录启动时长。 3. FlutterMain.initConfig private static void initConfig(@NonNull Context applicationContext) { Bundle metadata = getApplicationInfo(applicationContext).metaData; // There isn't a `` tag as a direct child of `` in // `AndroidManifest.xml`. if (metadata == null) { return; } //libapp.so sAotSharedLibraryName = metadata.getString(PUBLIC_AOT_SHARED_LIBRARY_NAME, DEFAULT_AOT_SHARED_LIBRARY_NAME); //flutter_assets sFlutterAssetsDir = metadata.getString(PUBLIC_FLUTTER_ASSETS_DIR_KEY, DEFAULT_FLUTTER_ASSETS_DIR); //vm_snapshot_data sVmSnapshotData = metadata.getString(PUBLIC_VM_SNAPSHOT_DATA_KEY, DEFAULT_VM_SNAPSHOT_DATA); //isolate_snapshot_data sIsolateSnapshotData = metadata.getString(PUBLIC_ISOLATE_SNAPSHOT_DATA_KEY, DEFAULT_ISOLATE_SNAPSHOT_DATA); } 这个方法主要是读取清单文件中的一些配置。如果没有配置则赋予默认值。 属性名 默认名 sAotSharedLibraryName libapp.so sFlutterAssetsDir flutter_assets sVmSnapshotData vm_snapshot_data sIsolateSnapshotData isolate_snapshot_data 4. FlutterMain.initResources private static void initResources(@NonNull Context applicationContext) { // 资源清理工作 new ResourceCleaner(applicationContext).start(); if (BuildConfig.DEBUG || BuildConfig.JIT_RELEASE) { final String dataDirPath = PathUtils.getDataDirectory(applicationContext); final String packageName = applicationContext.getPackageName(); final PackageManager packageManager = applicationContext.getPackageManager(); final AssetManager assetManager = applicationContext.getResources().getAssets(); sResourceExtractor = new ResourceExtractor(dataDirPath, packageName, packageManager, assetManager); // debug或者jit 模式下加载资源到内存供DartVM使用 sResourceExtractor .addResource(fromFlutterAssets(sVmSnapshotData)) .addResource(fromFlutterAssets(sIsolateSnapshotData)) .addResource(fromFlutterAssets(DEFAULT_KERNEL_BLOB)); sResourceExtractor.start(); } } 这个方法主要做了两件事： 启动清理资源工作。 debug 或者jit 模式下加载相关资源。 5. System.loadLibrary 在上面我们提到，FlutterMain 会加载flutter.so 库工作。而最终会调用到库中的JNI_OnLoad 方法。 // This is called by the VM when the shared library is first loaded. JNIEXPORT jint JNI_OnLoad(JavaVM* vm, void* reserved) { // Initialize the Java VM. fml::jni::InitJavaVM(vm); // 关联当前线程与jvm JNIEnv* env = fml::jni::AttachCurrentThread(); bool result = false; // Register FlutterMain. result = flutter::FlutterMain::Register(env); FML_CHECK(result); // Register PlatformView result = flutter::PlatformViewAndroid::Register(env); FML_CHECK(result); // Register VSyncWaiter. result = flutter::VsyncWaiterAndroid::Register(env); FML_CHECK(result); return JNI_VERSION_1_4; } （flutter/shell/platform/android/library_loader.cc） 这里主要做了4件事： 初始化JVM。 注册FlutterMain。 注册PlatformView。 注册VSyncWaiter。 5.1 InitJavaVM void InitJavaVM(JavaVM* vm) { FML_DCHECK(g_jvm == nullptr); g_jvm = vm; } （flutter/fml/platform/android/jni_util.cc） 这里主要是把当前进程创建的JVM 保存到静态变量中。 5.2 FlutterMain::Register bool FlutterMain::Register(JNIEnv* env) { static const JNINativeMethod methods[] = { { .name = \"nativeInit\", .signature = \"(Landroid/content/Context;[Ljava/lang/String;Ljava/\" \"lang/String;Ljava/lang/String;Ljava/lang/String;)V\", .fnPtr = reinterpret_cast(&Init), }, { .name = \"nativeRecordStartTimestamp\", .signature = \"(J)V\", .fnPtr = reinterpret_cast(&RecordStartTimestamp), }, }; jclass clazz = env->FindClass(\"io/flutter/embedding/engine/FlutterJNI\"); if (clazz == nullptr) { return false; } return env->RegisterNatives(clazz, methods, fml::size(methods)) == 0; } （flutter/shell/platform/android/flutter_main.cc） 这里主要注册了FlutterJNI的nativeInit 以及 nativeRecordStartTimestamp 方法。 5.3 PlatformViewAndroid::Register bool PlatformViewAndroid::Register(JNIEnv* env) { ... g_flutter_callback_info_class = new fml::jni::ScopedJavaGlobalRef( env, env->FindClass(\"io/flutter/view/FlutterCallbackInformation\")); ... g_flutter_callback_info_constructor = env->GetMethodID( g_flutter_callback_info_class->obj(), \"\", \"(Ljava/lang/String;Ljava/lang/String;Ljava/lang/String;)V\"); ... g_flutter_jni_class = new fml::jni::ScopedJavaGlobalRef( env, env->FindClass(\"io/flutter/embedding/engine/FlutterJNI\")); ... g_surface_texture_class = new fml::jni::ScopedJavaGlobalRef( env, env->FindClass(\"android/graphics/SurfaceTexture\")); ... g_attach_to_gl_context_method = env->GetMethodID( g_surface_texture_class->obj(), \"attachToGLContext\", \"(I)V\"); ... g_update_tex_image_method = env->GetMethodID(g_surface_texture_class->obj(), \"updateTexImage\", \"()V\"); ... g_get_transform_matrix_method = env->GetMethodID( g_surface_texture_class->obj(), \"getTransformMatrix\", \"([F)V\"); ... g_detach_from_gl_context_method = env->GetMethodID( g_surface_texture_class->obj(), \"detachFromGLContext\", \"()V\"); ... return RegisterApi(env); } （flutter/shell/platform/android/platform_view_android_jni.cc） 这里以及后续调用的RegisterApi方法中都是进行java native 方法的注册。 其中主要是FlutterJNI。 5.4 VsyncWaiterAndroid::Register bool VsyncWaiterAndroid::Register(JNIEnv* env) { static const JNINativeMethod methods[] = {{ .name = \"nativeOnVsync\", .signature = \"(JJJ)V\", .fnPtr = reinterpret_cast(&OnNativeVsync), }}; jclass clazz = env->FindClass(\"io/flutter/embedding/engine/FlutterJNI\"); if (clazz == nullptr) { return false; } g_vsync_waiter_class = new fml::jni::ScopedJavaGlobalRef(env, clazz); FML_CHECK(!g_vsync_waiter_class->is_null()); g_async_wait_for_vsync_method_ = env->GetStaticMethodID( g_vsync_waiter_class->obj(), \"asyncWaitForVsync\", \"(J)V\"); FML_CHECK(g_async_wait_for_vsync_method_ != nullptr); return env->RegisterNatives(clazz, methods, fml::size(methods)) == 0; } 这里也是注册了java 与c++ 互调的方法。 6. FlutterJNI.nativeRecordStartTimestamp Copyright © david 2019 all right reserved，powered by Gitbook该文件修订时间： 2020-04-28 16:03:17 "},"0-Flutter/7-Flutter 引擎启动v1-12.html":{"url":"0-Flutter/7-Flutter 引擎启动v1-12.html","title":"Flutter引擎启动","keywords":"","body":"Flutter引擎启动 (1.12) 前言 本文记录分析flutter 启动再到 Dart main 方法回调过程（基于 v1.12.13-hotfixes 版本）。 先看下Android 端如何启动一个Flutter 页面。以使用FlutterActivity 为例： Android 端调用启动flutter 页面。 默认启动方式: myButton.setOnClickListener { startActivity( FlutterActivity.createDefaultIntent(this) ) } 而其中FlutterActivity.createDefaultIntent方法其实是创建了一个intent 进行跳转。 public Intent build(@NonNull Context context) { return new Intent(context, activityClass) .putExtra(EXTRA_INITIAL_ROUTE, initialRoute) .putExtra(EXTRA_BACKGROUND_MODE, backgroundMode) .putExtra(EXTRA_DESTROY_ENGINE_WITH_ACTIVITY, true); } 主要携带三个信息： 初始路由，默认为\"/\" Backgroud_Mode，默认为opaque（不透明） 退出Activity时候是否销毁engine , 默认为true FlutterActivity.onCreate (io.flutter.embedding.android.FlutterActivity.java) protected void onCreate(@Nullable Bundle savedInstanceState) { switchLaunchThemeForNormalTheme(); super.onCreate(savedInstanceState); // 关联生命周期 lifecycle.handleLifecycleEvent(Lifecycle.Event.ON_CREATE); // 创建代理类 delegate = new FlutterActivityAndFragmentDelegate(this); delegate.onAttach(this); delegate.onActivityCreated(savedInstanceState); configureWindowForTransparency(); // 设置contentview setContentView(createFlutterView()); configureStatusBarForFullscreenFlutterExperience(); } 为了适配Activity 以及Fragment，这里很多工作其实交给代理类去实现，而Activity 的onCreate方法内主要做了两件事： 创建FlutterActivityAndFragmentDelegate类，调用其onAttach 以及onActivityCreated 方法 调用crateFlutterView方法创建并设置contentview FlutterActivityAndFragmentDelegate.onAttach （io.flutter.embedding.android.FlutterActivityAndFragmentDelegate.java） void onAttach(@NonNull Context context) { ensureAlive(); if (flutterEngine == null) { // 创建设置flutter 引擎 setupFlutterEngine(); } platformPlugin = host.providePlatformPlugin(host.getActivity(), flutterEngine); if (host.shouldAttachEngineToActivity()) { Log.d(TAG, \"Attaching FlutterEngine to the Activity that owns this Fragment.\"); flutterEngine.getActivityControlSurface().attachToActivity( host.getActivity(), host.getLifecycle() ); } setupFlutterEngine() 主要是创建FlutterEngine /* package */ void setupFlutterEngine() { // 如果使用了缓存engine String cachedEngineId = host.getCachedEngineId(); if (cachedEngineId != null) { flutterEngine = FlutterEngineCache.getInstance().get(cachedEngineId); isFlutterEngineFromHost = true; if (flutterEngine == null) { throw new IllegalStateException(\"The requested cached FlutterEngine did not exist in the FlutterEngineCache: '\" + cachedEngineId + \"'\"); } return; } // 如果host 提供了flutter engine flutterEngine = host.provideFlutterEngine(host.getContext()); if (flutterEngine != null) { isFlutterEngineFromHost = true; return; } // 创建flutter engine Log.d(TAG, \"No preferred FlutterEngine was provided. Creating a new FlutterEngine for\" + \" this FlutterFragment.\"); flutterEngine = new FlutterEngine(host.getContext(), host.getFlutterShellArgs().toArray()); isFlutterEngineFromHost = false; } 这两个方法主要是： 创建FlutterEngine，遵循以下策略 若设置了cache Engine 则复用 若Host 提供了Engine 则使用 创建全新的Flutter Engine 初始化PlatformPlugin FlutterEngine 创建 不管是使用cache Engine 还是new Engine 方式启动flutter 都涉及创建一个FlutterEngine 对象。而创建FlutterEngine 对象内部又做了什么呢？ （io.flutter.embedding.engine.FlutterEngine.java） public FlutterEngine( @NonNull Context context, @NonNull FlutterLoader flutterLoader, @NonNull FlutterJNI flutterJNI, @Nullable String[] dartVmArgs, boolean automaticallyRegisterPlugins ) { this.flutterJNI = flutterJNI; // 启动Flutter ，开始进行初始化 flutterLoader.startInitialization(context); // 确保初始化完成 flutterLoader.ensureInitializationComplete(context, dartVmArgs); flutterJNI.addEngineLifecycleListener(engineLifecycleListener); // 关联native attachToJni(); // 注册platform message 通道 this.dartExecutor = new DartExecutor(flutterJNI, context.getAssets()); this.dartExecutor.onAttachedToJNI(); this.renderer = new FlutterRenderer(flutterJNI); // 建立各种 method channel ..... this.pluginRegistry = new FlutterEnginePluginRegistry( context.getApplicationContext(), this, flutterLoader ); // 内部反射调用类GeneratedPluginRegistrant的registerWith方法实现第三方的插件注册 if (automaticallyRegisterPlugins) { registerPlugins(); } } 这里FlutterEngine 构造方法所做的事有： 创建FlutterJNI以及FlutterLoader 对象 调用flutterLoader 进行初始化 确保初始化完成 attachJni 关联native 注册platform 各种插件 反射注册第三方插件 startInitialization 开始初始化 flutterLoader 开始进行初始化。 public void startInitialization(@NonNull Context applicationContext, @NonNull Settings settings) { // 确保不重复初始化 if (this.settings != null) { return; } // 确保在主线程 if (Looper.myLooper() != Looper.getMainLooper()) { throw new IllegalStateException(\"startInitialization must be called on the main thread\"); } this.settings = settings; long initStartTimestampMillis = SystemClock.uptimeMillis(); // 初始化清单文件中的配置 initConfig(applicationContext); // 清理、提取资源等操作 initResources(applicationContext); // 加载flutter.so 库 System.loadLibrary(\"flutter\"); VsyncWaiter .getInstance((WindowManager) applicationContext.getSystemService(Context.WINDOW_SERVICE)) .init(); long initTimeMillis = SystemClock.uptimeMillis() - initStartTimestampMillis; // 记录初始化时间 FlutterJNI.nativeRecordStartTimestamp(initTimeMillis); } Flutter加载器初始化里面主要做的工作是： 提取配置信息 清理、提取资源 加载flutter.so 库 记录初始化耗费时间 flutter.so 库加载 在FlutterLoader.startInitialization 中我们看见加载了flutter.so 动态库，而动态库加载最终会调用到库中的JNI_OnLoad方法。 (flutter/shell/platform/android/library_loader.cc) JNIEXPORT jint JNI_OnLoad(JavaVM* vm, void* reserved) { // Initialize the Java VM. fml::jni::InitJavaVM(vm); JNIEnv* env = fml::jni::AttachCurrentThread(); bool result = false; // Register FlutterMain. result = flutter::FlutterMain::Register(env); FML_CHECK(result); // Register PlatformView result = flutter::PlatformViewAndroid::Register(env); FML_CHECK(result); // Register VSyncWaiter. result = flutter::VsyncWaiterAndroid::Register(env); FML_CHECK(result); return JNI_VERSION_1_4; } 这里主要完成注册工作。 初始化JVM 虚拟机 注册FlutterMain 注册PlatformView 注册VSyncWaiter 关联 JVM 虚拟机 （flutter/fml/platform/android/jni_util.cc） void InitJavaVM(JavaVM* vm) { FML_DCHECK(g_jvm == nullptr); g_jvm = vm; } 这里主要是关联当前进程创建的JVM 实例，并且保存成静态变量。 注册FlutterMain （flutter/shell/platform/android/flutter_main.cc） bool FlutterMain::Register(JNIEnv* env) { static const JNINativeMethod methods[] = { { .name = \"nativeInit\", .signature = \"(Landroid/content/Context;[Ljava/lang/String;Ljava/\" \"lang/String;Ljava/lang/String;Ljava/lang/String;)V\", .fnPtr = reinterpret_cast(&Init), }, { .name = \"nativeRecordStartTimestamp\", .signature = \"(J)V\", .fnPtr = reinterpret_cast(&RecordStartTimestamp), }, }; jclass clazz = env->FindClass(\"io/flutter/embedding/engine/FlutterJNI\"); if (clazz == nullptr) { return false; } return env->RegisterNatives(clazz, methods, fml::size(methods)) == 0; } 这里主要是注册了FlutterJNI(在1.9中是FlutterMain类)中的 nativeInit 以及nativeRecordStartTimestamp方法。 注册PlatformView （flutter/shell/platform/android/platform_view_android_jni.cc） bool PlatformViewAndroid::Register(JNIEnv* env) { if (env == nullptr) { FML_LOG(ERROR) ( env, env->FindClass(\"io/flutter/view/FlutterCallbackInformation\")); if (g_flutter_callback_info_class->is_null()) { FML_LOG(ERROR) 这里也是进行方法注册调用。 注册VSyncWaiter (flutter/shell/platform/android/vsync_waiter_android.cc) bool VsyncWaiterAndroid::Register(JNIEnv* env) { static const JNINativeMethod methods[] = {{ .name = \"nativeOnVsync\", .signature = \"(JJJ)V\", .fnPtr = reinterpret_cast(&OnNativeVsync), }}; jclass clazz = env->FindClass(\"io/flutter/embedding/engine/FlutterJNI\"); if (clazz == nullptr) { return false; } g_vsync_waiter_class = new fml::jni::ScopedJavaGlobalRef(env, clazz); FML_CHECK(!g_vsync_waiter_class->is_null()); g_async_wait_for_vsync_method_ = env->GetStaticMethodID( g_vsync_waiter_class->obj(), \"asyncWaitForVsync\", \"(J)V\"); FML_CHECK(g_async_wait_for_vsync_method_ != nullptr); return env->RegisterNatives(clazz, methods, fml::size(methods)) == 0; } 这里也是把FlutterJNI 的nativeOnVsync 方法与C++ 层的 OnNativeVsync 关联，让java 可以调用C++ 的方法、 把JAVA 层的 asyncWaitForVsync方法保存到C++ 的 gasync_wait_for_vsync_method 变量，让C++ 可以调用JAVA。 所以上面Flutter加载的初始化工作主要是进行资源整合，加载so 库，以及native 与 java 层的通信方法注册。 ensureInitializationComplete 初始化完成 上面调用只是注册了一些通信方法，实际上初始化工作还未完成。调用ensureInitializationComplete方法确保初始化完成。 public void ensureInitializationComplete(@NonNull Context applicationContext, @Nullable String[] args) { .... try { if (resourceExtractor != null) { resourceExtractor.waitForCompletion(); } List shellArgs = new ArrayList<>(); ... // 构建启动参数 ... String appStoragePath = PathUtils.getFilesDir(applicationContext); String engineCachesPath = PathUtils.getCacheDirectory(applicationContext); // native 初始化 FlutterJNI.nativeInit(applicationContext, shellArgs.toArray(new String[0]), kernelPath, appStoragePath, engineCachesPath); initialized = true; } catch (Exception e) { Log.e(TAG, \"Flutter initialization failed.\", e); throw new RuntimeException(e); } } 其中做的事情是： 构建启动shell 参数列表 调用FlutterJNI.nativeInit 进行native 初始化工作。 nativeInit FlutterJNI.nativeInit public static native void nativeInit( @NonNull Context context, @NonNull String[] args, @Nullable String bundlePath, @NonNull String appStoragePath, @NonNull String engineCachesPath ); 从上面的so 库加载可以看到nativeInit 方法映射到c++ 中是 FlutterMain::Init 方法 FlutterMain::Init (flutter/shell/platform/android/flutter_main.cc) void FlutterMain::Init(JNIEnv* env, jclass clazz, jobject context, jobjectArray jargs, jstring kernelPath, jstring appStoragePath, jstring engineCachesPath) { std::vector args; args.push_back(\"flutter\"); for (auto& arg : fml::jni::StringArrayToVector(env, jargs)) { args.push_back(std::move(arg)); } auto command_line = fml::CommandLineFromIterators(args.begin(), args.end()); // 记录传入的参数 auto settings = SettingsFromCommandLine(command_line); flutter::DartCallbackCache::SetCachePath( fml::jni::JavaStringToString(env, appStoragePath)); fml::paths::InitializeAndroidCachesPath( fml::jni::JavaStringToString(env, engineCachesPath)); // 磁盘中载入缓存 flutter::DartCallbackCache::LoadCacheFromDisk(); ... g_flutter_main.reset(new FlutterMain(std::move(settings))); g_flutter_main->SetupObservatoryUriCallback(env); } 该方法主要是把传入的args 以及资源文件路径等信息保存在Setting 类中。 attachToJni 在完成初始化后，flutter engine 还调用了attachToJni 方法 ，而内部是调用FlutterJNI的attachToNative方法： @UiThread public void attachToNative(boolean isBackgroundView) { // isBackgroundView = false ensureRunningOnMainThread(); ensureNotAttachedToNative(); nativePlatformViewId = nativeAttach(this, isBackgroundView); } 而nativeAttach 是个native 方法 在platform_view_android_jni.cc 中 { .name = \"nativeAttach\", .signature = \"(Lio/flutter/embedding/engine/FlutterJNI;Z)J\", .fnPtr = reinterpret_cast(&AttachJNI), } 关联了AttachJNI 方法 AttachJNI （flutter/shell/platform/android/platform_view_android_jni.cc） // Called By Java static jlong AttachJNI(JNIEnv* env, jclass clazz, jobject flutterJNI, jboolean is_background_view) { fml::jni::JavaObjectWeakGlobalRef java_object(env, flutterJNI); auto shell_holder = std::make_unique( FlutterMain::Get().GetSettings(), java_object, is_background_view); if (shell_holder->IsValid()) { return reinterpret_cast(shell_holder.release()); } else { return 0; } } 这里主要是初始化AndroidShellHolder对象。而这个对象内部又做了什么呢？ AndroidShellHolder 初始化 （flutter/shell/platform/android/android_shell_holder.cc） AndroidShellHolder::AndroidShellHolder( flutter::Settings settings, fml::jni::JavaObjectWeakGlobalRef java_object, bool is_background_view) : settings_(std::move(settings)), java_object_(java_object) { static size_t shell_count = 1; auto thread_label = std::to_string(shell_count++); FML_CHECK(pthread_key_create(&thread_destruct_key_, ThreadDestructCallback) == 0); if (is_background_view) { ... } else { // 创建UI，GPU，IO 线程 thread_host_ = {thread_label, ThreadHost::Type::UI | ThreadHost::Type::GPU | ThreadHost::Type::IO}; } // 当ui ，gpu 线程停止时候分离jni auto jni_exit_task([key = thread_destruct_key_]() { FML_CHECK(pthread_setspecific(key, reinterpret_cast(1)) == 0); }); thread_host_.ui_thread->GetTaskRunner()->PostTask(jni_exit_task); if (!is_background_view) { thread_host_.gpu_thread->GetTaskRunner()->PostTask(jni_exit_task); } fml::WeakPtr weak_platform_view; // 创建PlatformView Shell::CreateCallback on_create_platform_view = [is_background_view, java_object, &weak_platform_view](Shell& shell) { std::unique_ptr platform_view_android; if (is_background_view) { ... } else { // 创建 PlatformViewAndroid platform_view_android = std::make_unique( shell, // delegate shell.GetTaskRunners(), // task runners java_object, // java object handle for JNI interop shell.GetSettings() .enable_software_rendering // use software rendering ); } weak_platform_view = platform_view_android->GetWeakPtr(); return platform_view_android; }; Shell::CreateCallback on_create_rasterizer = [](Shell& shell) { return std::make_unique(shell, shell.GetTaskRunners()); }; // 当前线程作为platform 线程，初始化MessageLoop fml::MessageLoop::EnsureInitializedForCurrentThread(); fml::RefPtr gpu_runner; fml::RefPtr ui_runner; fml::RefPtr io_runner; fml::RefPtr platform_runner = fml::MessageLoop::GetCurrent().GetTaskRunner(); if (is_background_view) { ... } else { gpu_runner = thread_host_.gpu_thread->GetTaskRunner(); ui_runner = thread_host_.ui_thread->GetTaskRunner(); io_runner = thread_host_.io_thread->GetTaskRunner(); } // 创建 task_runners flutter::TaskRunners task_runners(thread_label, // label platform_runner, // platform gpu_runner, // gpu ui_runner, // ui io_runner // io ); // 创建 shell shell_ = Shell::Create(task_runners, // task runners settings_, // settings on_create_platform_view, // platform view create callback on_create_rasterizer // rasterizer create callback ); platform_view_ = weak_platform_view; FML_DCHECK(platform_view_); is_valid_ = shell_ != nullptr; if (is_valid_) { //提升GPU 线程优先级 task_runners.GetGPUTaskRunner()->PostTask([]() { if (::setpriority(PRIO_PROCESS, gettid(), -5) != 0) { if (::setpriority(PRIO_PROCESS, gettid(), -2) != 0) { FML_LOG(ERROR) PostTask([]() { if (::setpriority(PRIO_PROCESS, gettid(), -1) != 0) { FML_LOG(ERROR) 这个方法很长，梳理下，主要是： 初始化ui、gpu、io 线程 创建PlatformView 创建Rasterizer 创建Shell ThreadHost创建 （flutter/shell/common/thread_host.cc） ThreadHost::ThreadHost(std::string name_prefix, uint64_t mask) { if (mask & ThreadHost::Type::Platform) { platform_thread = std::make_unique(name_prefix + \".platform\"); } if (mask & ThreadHost::Type::UI) { ui_thread = std::make_unique(name_prefix + \".ui\"); } if (mask & ThreadHost::Type::GPU) { gpu_thread = std::make_unique(name_prefix + \".gpu\"); } if (mask & ThreadHost::Type::IO) { io_thread = std::make_unique(name_prefix + \".io\"); } } 在flutter 的native 层有4个线程，分别是platform，ui，gpu，io 。而在上面的AndroidShellHolder初始化中，创建了ui，gpu，ui 线程，而把当前线程作为platform线程。 PlatformView 创建 (flutter/shell/platform/android/platform_view_android.cc) PlatformViewAndroid::PlatformViewAndroid( PlatformView::Delegate& delegate, flutter::TaskRunners task_runners, fml::jni::JavaObjectWeakGlobalRef java_object, bool use_software_rendering) : PlatformView(delegate, std::move(task_runners)), java_object_(java_object), android_surface_(AndroidSurface::Create(use_software_rendering)) { FML_CHECK(android_surface_) 看一看见platformViewAndroid 继承自PlatformView。 todo Shell 创建 在AndroidShellHolder 初始化中，创建了shell 对象，这里看下里面做了什么。 (flutter/shell/common/shell.cc) std::unique_ptr Shell::Create( TaskRunners task_runners, Settings settings, const Shell::CreateCallback& on_create_platform_view, const Shell::CreateCallback& on_create_rasterizer) { PerformInitializationTasks(settings); PersistentCache::SetCacheSkSL(settings.cache_sksl); TRACE_EVENT0(\"flutter\", \"Shell::Create\"); // 创建DartVM auto vm = DartVMRef::Create(settings); FML_CHECK(vm) GetVMData(); // return Shell::Create(std::move(task_runners), // std::move(settings), // vm_data->GetIsolateSnapshot(), // isolate snapshot on_create_platform_view, // on_create_rasterizer, // std::move(vm) // ); } 这里并没有直接创建Shell ，而是先创建了Dart虚拟机，然后调用Shell::Create 方法。 Dart 虚拟机创建 (flutter/runtime/dart_vm_lifecycle.cc) DartVMRef DartVMRef::Create(Settings settings, fml::RefPtr vm_snapshot, fml::RefPtr isolate_snapshot) { std::scoped_lock lifecycle_lock(gVMMutex); if (!settings.leak_vm) { FML_CHECK(!gVMLeak) (); auto vm = DartVM::Create(std::move(settings), // std::move(vm_snapshot), // std::move(isolate_snapshot), // isolate_name_server // ); if (!vm) { FML_LOG(ERROR) GetVMData(); gVMServiceProtocol = vm->GetServiceProtocol(); gVMIsolateNameServer = isolate_name_server; gVM = vm; if (settings.leak_vm) { gVMLeak = new std::shared_ptr(vm); } return DartVMRef{std::move(vm)}; } 这里是创建Dart 虚拟机，当进程存在时候复用。 Todo Shell::Create （flutter/shell/common/shell.cc） std::unique_ptr Shell::Create( TaskRunners task_runners, Settings settings, fml::RefPtr isolate_snapshot, const Shell::CreateCallback& on_create_platform_view, const Shell::CreateCallback& on_create_rasterizer, DartVMRef vm) { .... fml::TaskRunner::RunNowOrPostTask( task_runners.GetPlatformTaskRunner(), fml::MakeCopyable([&latch, // vm = std::move(vm), // &shell, // task_runners = std::move(task_runners), // settings, // isolate_snapshot = std::move(isolate_snapshot), // on_create_platform_view, // on_create_rasterizer // ]() mutable { // 真正shell 创建 shell = CreateShellOnPlatformThread(std::move(vm), std::move(task_runners), // settings, // std::move(isolate_snapshot), // on_create_platform_view, // on_create_rasterizer // ); latch.Signal(); })); // 等待shell 创建完成 latch.Wait(); return shell; } 这个重载方法里面也没有真正创建shell，实际创建交给CreateShellOnPlatformThread完成. CreateShellOnPlatformThread （flutter/shell/common/shell.cc） std::unique_ptr Shell::CreateShellOnPlatformThread( DartVMRef vm, TaskRunners task_runners, Settings settings, fml::RefPtr isolate_snapshot, const Shell::CreateCallback& on_create_platform_view, const Shell::CreateCallback& on_create_rasterizer) { ... // 创建shell 对象 （终于创建了！！！！） auto shell = std::unique_ptr(new Shell(std::move(vm), task_runners, settings)); // 在GPU 线程创建 rasterizer std::promise> rasterizer_promise; auto rasterizer_future = rasterizer_promise.get_future(); std::promise> snapshot_delegate_promise; auto snapshot_delegate_future = snapshot_delegate_promise.get_future(); fml::TaskRunner::RunNowOrPostTask( task_runners.GetGPUTaskRunner(), [&rasterizer_promise, // &snapshot_delegate_promise, on_create_rasterizer, // shell = shell.get() // ]() { TRACE_EVENT0(\"flutter\", \"ShellSetupGPUSubsystem\"); std::unique_ptr rasterizer(on_create_rasterizer(*shell)); snapshot_delegate_promise.set_value(rasterizer->GetSnapshotDelegate()); rasterizer_promise.set_value(std::move(rasterizer)); }); // 在platform 线程（当前线程）创建 platformView，其实在创建AndroidShellHolder时候创建 auto platform_view = on_create_platform_view(*shell.get()); if (!platform_view || !platform_view->GetWeakPtr()) { return nullptr; } // 创建vsync_waiter. auto vsync_waiter = platform_view->CreateVSyncWaiter(); if (!vsync_waiter) { return nullptr; } // 在IO 线程创建 ShellIOManager 对象 std::promise> io_manager_promise; auto io_manager_future = io_manager_promise.get_future(); std::promise> weak_io_manager_promise; auto weak_io_manager_future = weak_io_manager_promise.get_future(); std::promise> unref_queue_promise; auto unref_queue_future = unref_queue_promise.get_future(); auto io_task_runner = shell->GetTaskRunners().GetIOTaskRunner(); fml::TaskRunner::RunNowOrPostTask( io_task_runner, [&io_manager_promise, // &weak_io_manager_promise, // &unref_queue_promise, // platform_view = platform_view->GetWeakPtr(), // io_task_runner, // is_backgrounded_sync_switch = shell->GetIsGpuDisabledSyncSwitch() // ]() { TRACE_EVENT0(\"flutter\", \"ShellSetupIOSubsystem\"); auto io_manager = std::make_unique( platform_view.getUnsafe()->CreateResourceContext(), is_backgrounded_sync_switch, io_task_runner); weak_io_manager_promise.set_value(io_manager->GetWeakPtr()); unref_queue_promise.set_value(io_manager->GetSkiaUnrefQueue()); io_manager_promise.set_value(std::move(io_manager)); }); auto dispatcher_maker = platform_view->GetDispatcherMaker(); // UI 线程创建 Engine 对象 std::promise> engine_promise; auto engine_future = engine_promise.get_future(); fml::TaskRunner::RunNowOrPostTask( shell->GetTaskRunners().GetUITaskRunner(), fml::MakeCopyable([&engine_promise, // shell = shell.get(), // &dispatcher_maker, // isolate_snapshot = std::move(isolate_snapshot), // vsync_waiter = std::move(vsync_waiter), // &weak_io_manager_future, // &snapshot_delegate_future, // &unref_queue_future // ]() mutable { TRACE_EVENT0(\"flutter\", \"ShellSetupUISubsystem\"); const auto& task_runners = shell->GetTaskRunners(); // UI 线程创建 animator 对象 auto animator = std::make_unique(*shell, task_runners, std::move(vsync_waiter)); engine_promise.set_value(std::make_unique( *shell, // dispatcher_maker, // *shell->GetDartVM(), // std::move(isolate_snapshot), // task_runners, // shell->GetSettings(), // std::move(animator), // weak_io_manager_future.get(), // unref_queue_future.get(), // snapshot_delegate_future.get() // )); })); if (!shell->Setup(std::move(platform_view), // engine_future.get(), // rasterizer_future.get(), // io_manager_future.get()) // ) { return nullptr; } return shell; } 这一段代码较多，但里面基本上是对象的创建。 创建shell 对象 GPU 线程中创建Rasterizer 获取之前创建的platformView 创建vsync_waiter IO线程中创建ShellIOManager UI 线程创建 Engine 对象 UI 线程中创建Animator Shell 构建 (flutter/shell/common/shell.cc) Shell::Shell(DartVMRef vm, TaskRunners task_runners, Settings settings) : task_runners_(std::move(task_runners)), settings_(std::move(settings)), vm_(std::move(vm)), is_gpu_disabled_sync_switch_(new fml::SyncSwitch()), weak_factory_(this), weak_factory_gpu_(nullptr) { FML_CHECK(vm_) RunsTasksOnCurrentThread()); fml::TaskRunner::RunNowOrPostTask( task_runners_.GetGPUTaskRunner(), fml::MakeCopyable([this]() mutable { this->weak_factory_gpu_ = std::make_unique>(this); })); service_protocol_handlers_[ServiceProtocol::kScreenshotExtensionName] = { task_runners_.GetGPUTaskRunner(), std::bind(&Shell::OnServiceProtocolScreenshot, this, std::placeholders::_1, std::placeholders::_2)}; service_protocol_handlers_[ServiceProtocol::kScreenshotSkpExtensionName] = { task_runners_.GetGPUTaskRunner(), std::bind(&Shell::OnServiceProtocolScreenshotSKP, this, std::placeholders::_1, std::placeholders::_2)}; service_protocol_handlers_[ServiceProtocol::kRunInViewExtensionName] = { task_runners_.GetUITaskRunner(), std::bind(&Shell::OnServiceProtocolRunInView, this, std::placeholders::_1, std::placeholders::_2)}; service_protocol_handlers_ [ServiceProtocol::kFlushUIThreadTasksExtensionName] = { task_runners_.GetUITaskRunner(), std::bind(&Shell::OnServiceProtocolFlushUIThreadTasks, this, std::placeholders::_1, std::placeholders::_2)}; service_protocol_handlers_ [ServiceProtocol::kSetAssetBundlePathExtensionName] = { task_runners_.GetUITaskRunner(), std::bind(&Shell::OnServiceProtocolSetAssetBundlePath, this, std::placeholders::_1, std::placeholders::_2)}; service_protocol_handlers_ [ServiceProtocol::kGetDisplayRefreshRateExtensionName] = { task_runners_.GetUITaskRunner(), std::bind(&Shell::OnServiceProtocolGetDisplayRefreshRate, this, std::placeholders::_1, std::placeholders::_2)}; } 实际创建Shell 对象，关联之前创建的task_runners，settings，vm。 Engine 创建 （flutter/shell/common/engine.cc） Engine::Engine(Delegate& delegate, const PointerDataDispatcherMaker& dispatcher_maker, DartVM& vm, fml::RefPtr isolate_snapshot, TaskRunners task_runners, Settings settings, std::unique_ptr animator, fml::WeakPtr io_manager, fml::RefPtr unref_queue, fml::WeakPtr snapshot_delegate) : delegate_(delegate), settings_(std::move(settings)), animator_(std::move(animator)), activity_running_(true), have_surface_(false), image_decoder_(task_runners, vm.GetConcurrentWorkerTaskRunner(), io_manager), task_runners_(std::move(task_runners)), weak_factory_(this) { // 创建RuntimeController 对象 runtime_controller_ = std::make_unique( *this, // runtime delegate &vm, // VM std::move(isolate_snapshot), // isolate snapshot task_runners_, // task runners std::move(snapshot_delegate), std::move(io_manager), // io manager std::move(unref_queue), // Skia unref queue image_decoder_.GetWeakPtr(), // image decoder settings_.advisory_script_uri, // advisory script uri settings_.advisory_script_entrypoint, // advisory script entrypoint settings_.idle_notification_callback, // idle notification callback settings_.isolate_create_callback, // isolate create callback settings_.isolate_shutdown_callback, // isolate shutdown callback settings_.persistent_isolate_data // persistent isolate data ); pointer_data_dispatcher_ = dispatcher_maker(*this); } 这里创建了一个RuntimeController 对象。 RuntimeController 创建 （flutter/runtime/runtime_controller.cc） RuntimeController::RuntimeController( RuntimeDelegate& p_client, DartVM* p_vm, fml::RefPtr p_isolate_snapshot, TaskRunners p_task_runners, fml::WeakPtr p_snapshot_delegate, fml::WeakPtr p_io_manager, fml::RefPtr p_unref_queue, fml::WeakPtr p_image_decoder, std::string p_advisory_script_uri, std::string p_advisory_script_entrypoint, const std::function& idle_notification_callback, WindowData p_window_data, const fml::closure& p_isolate_create_callback, const fml::closure& p_isolate_shutdown_callback, std::shared_ptr p_persistent_isolate_data) : client_(p_client), vm_(p_vm), isolate_snapshot_(std::move(p_isolate_snapshot)), task_runners_(p_task_runners), snapshot_delegate_(p_snapshot_delegate), io_manager_(p_io_manager), unref_queue_(p_unref_queue), image_decoder_(p_image_decoder), advisory_script_uri_(p_advisory_script_uri), advisory_script_entrypoint_(p_advisory_script_entrypoint), idle_notification_callback_(idle_notification_callback), window_data_(std::move(p_window_data)), isolate_create_callback_(p_isolate_create_callback), isolate_shutdown_callback_(p_isolate_shutdown_callback), persistent_isolate_data_(std::move(p_persistent_isolate_data)) { //创建 root isolate auto strong_root_isolate = DartIsolate::CreateRootIsolate(vm_->GetVMData()->GetSettings(), // isolate_snapshot_, // task_runners_, // std::make_unique(this), // 创建windows snapshot_delegate_, // io_manager_, // unref_queue_, // image_decoder_, // p_advisory_script_uri, // p_advisory_script_entrypoint, // nullptr, // isolate_create_callback_, // isolate_shutdown_callback_ // ) .lock(); FML_CHECK(strong_root_isolate) SetReturnCodeCallback([this](uint32_t code) { root_isolate_return_code_ = {true, code}; }); if (auto* window = GetWindowIfAvailable()) { tonic::DartState::Scope scope(strong_root_isolate); window->DidCreateIsolate(); if (!FlushRuntimeStateToIsolate()) { FML_DLOG(ERROR) root isolate 创建 （flutter/runtime/dart_isolate.cc） std::weak_ptr DartIsolate::CreateRootIsolate( const Settings& settings, fml::RefPtr isolate_snapshot, TaskRunners task_runners, std::unique_ptr window, fml::WeakPtr snapshot_delegate, fml::WeakPtr io_manager, fml::RefPtr unref_queue, fml::WeakPtr image_decoder, std::string advisory_script_uri, std::string advisory_script_entrypoint, Dart_IsolateFlags* flags, const fml::closure& isolate_create_callback, const fml::closure& isolate_shutdown_callback) { TRACE_EVENT0(\"flutter\", \"DartIsolate::CreateRootIsolate\"); Dart_Isolate vm_isolate = nullptr; std::weak_ptr embedder_isolate; char* error = nullptr; // 创建DartIsolate auto root_embedder_data = std::make_unique>( std::shared_ptr(new DartIsolate( settings, // settings std::move(isolate_snapshot), // isolate snapshot task_runners, // task runners std::move(snapshot_delegate), // snapshot delegate std::move(io_manager), // IO manager std::move(unref_queue), // Skia unref queue std::move(image_decoder), // Image Decoder advisory_script_uri, // advisory URI advisory_script_entrypoint, // advisory entrypoint nullptr, // child isolate preparer isolate_create_callback, // isolate create callback isolate_shutdown_callback, // isolate shutdown callback true, // is_root_isolate true // is_group_root_isolate ))); // 创建 isolate std::tie(vm_isolate, embedder_isolate) = CreateDartVMAndEmbedderObjectPair( advisory_script_uri.c_str(), // advisory script URI advisory_script_entrypoint.c_str(), // advisory script entrypoint nullptr, // package root nullptr, // package config flags, // flags root_embedder_data.get(), // parent embedder data true, // is root isolate &error // error (out) ); if (error != nullptr) { free(error); } if (vm_isolate == nullptr) { return {}; } std::shared_ptr shared_embedder_isolate = embedder_isolate.lock(); if (shared_embedder_isolate) { // Only root isolates can interact with windows. shared_embedder_isolate->SetWindow(std::move(window)); } root_embedder_data.release(); return embedder_isolate; } 这里创建了Isolate 。 Todo windows 创建 （flutter/lib/ui/window/window.cc） Window::Window(WindowClient* client) : client_(client) {} Todo 创建FlutterView FlutterActivity.createFlutterView 在FlutterActivity 中通过调用createFlutterView 方法来设置contentView private View createFlutterView() { return delegate.onCreateView( null /* inflater */, null /* container */, null /* savedInstanceState */); } 主要把创建工作交给代理类FlutterActivityAndFragmentDelegate View onCreateView(LayoutInflater inflater, @Nullable ViewGroup container, @Nullable Bundle savedInstanceState) { Log.v(TAG, \"Creating FlutterView.\"); ensureAlive(); //创建flutter View flutterView = new FlutterView(host.getActivity(), host.getRenderMode(), host.getTransparencyMode()); // 添加显示监听 flutterView.addOnFirstFrameRenderedListener(flutterUiDisplayListener); //创建flutterSplashView flutterSplashView = new FlutterSplashView(host.getContext()); // 设置id if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.JELLY_BEAN_MR1) { flutterSplashView.setId(View.generateViewId()); } else { flutterSplashView.setId(486947586); } // 关联flutter view flutterSplashView.displayFlutterViewWithSplash(flutterView, host.provideSplashScreen()); return flutterSplashView; } 这里主要做了以下工作： 创建flutter view 创建flutterSplashView 调用FlutterSplashView 的 displayFlutterViewWithSplash 方法关联flutterView 返回flutterSplashView 所以设置到Activity 的view 其实是flutterSplashView。而FlutterSplashView 主要是控制FlutterView 未显示时候添加SplashView。 FlutterView 初始化 构造内部调用init 方法。 private void init() { Log.v(TAG, \"Initializing FlutterView\"); switch (renderMode) { case surface: Log.v(TAG, \"Internally using a FlutterSurfaceView.\"); FlutterSurfaceView flutterSurfaceView = new FlutterSurfaceView(getContext(), transparencyMode == TransparencyMode.transparent); renderSurface = flutterSurfaceView; addView(flutterSurfaceView); break; case texture: Log.v(TAG, \"Internally using a FlutterTextureView.\"); FlutterTextureView flutterTextureView = new FlutterTextureView(getContext()); renderSurface = flutterTextureView; addView(flutterTextureView); break; } // FlutterView needs to be focusable so that the InputMethodManager can interact with it. setFocusable(true); setFocusableInTouchMode(true); } 根据渲染模式创建FlutterSurfaceView 或者FlutterTextureView，默认是surface 模式。 FlutterSurfaceView 初始化 FlutterSurface 构造内也调用了init 方法： private void init() { // If transparency is desired then we'll enable a transparent pixel format and place // our Window above everything else to get transparent background rendering. if (renderTransparently) { getHolder().setFormat(PixelFormat.TRANSPARENT); setZOrderOnTop(true); } // 添加surface callback getHolder().addCallback(surfaceCallback); // 避免黑屏先设置透明 setAlpha(0.0f); } 而surfaceCallback 里面 调用了connectSurfaceToRenderer 方法，而最终会调用flutterJNI 的 onSurfaceCreated 方法： @UiThread public void onSurfaceCreated(@NonNull Surface surface) { ensureRunningOnMainThread(); ensureAttachedToNative(); nativeSurfaceCreated(nativePlatformViewId, surface); } 而nativeSurfaceCreated 方法注册： (flutter/shell/platform/android/platform_view_android_jni.cc RegisterApi 方法内) { .name = \"nativeSurfaceCreated\", .signature = \"(JLandroid/view/Surface;)V\", .fnPtr = reinterpret_cast(&SurfaceCreated), }, 最终映射到SurfaceCreated 方法内。 static void SurfaceCreated(JNIEnv* env, jobject jcaller, jlong shell_holder, jobject jsurface) { fml::jni::ScopedJavaLocalFrame scoped_local_reference_frame(env); // 创建AndroidNativeWindow 对象 auto window = fml::MakeRefCounted( ANativeWindow_fromSurface(env, jsurface)); ANDROID_SHELL_HOLDER->GetPlatformView()->NotifyCreated(std::move(window)); } FlutterActivity.onStart 前面可以看见在FlutterActivity 的onCreate 方法内主要进行一些初始化工作，还未加载dart 入口函数部分。 接下来看下FlutterActivity 的onStart 方法： protected void onStart() { super.onStart(); lifecycle.handleLifecycleEvent(Lifecycle.Event.ON_START); delegate.onStart(); } 里面主要调用的是代理类的onStart方法： void onStart() { Log.v(TAG, \"onStart()\"); ensureAlive(); new Handler().post(new Runnable() { @Override public void run() { Log.v(TAG, \"Attaching FlutterEngine to FlutterView.\"); flutterView.attachToFlutterEngine(flutterEngine); doInitialFlutterViewRun(); } }); } attachToFlutterEngine flutterview 与 Engine 关联 public void attachToFlutterEngine( @NonNull FlutterEngine flutterEngine ) { .... this.flutterEngine = flutterEngine; // Instruct our FlutterRenderer that we are now its designated RenderSurface. FlutterRenderer flutterRenderer = this.flutterEngine.getRenderer(); isFlutterUiDisplayed = flutterRenderer.isDisplayingFlutterUi(); renderSurface.attachToRenderer(flutterRenderer); flutterRenderer.addIsDisplayingFlutterUiListener(flutterUiDisplayListener); // 关联原生输入，触摸等 ..... flutterEngine.getPlatformViewsController().attachToView(this); // Notify engine attachment listeners of the attachment. for (FlutterEngineAttachmentListener listener : flutterEngineAttachmentListeners) { listener.onFlutterEngineAttachedToFlutterView(flutterEngine); } // 如果FlutterUi第一帧显示，通知监听器 if (isFlutterUiDisplayed) { flutterUiDisplayListener.onFlutterUiDisplayed(); } } 这里主要是关联一些原生的输入法输入，触摸等事件，以及处理一些监听回调。 doInitialFlutterViewRun (FlutterActivityAndFragmentDelegate) private void doInitialFlutterViewRun() { // 如果使用了缓存的Engine ，return 不再启动Engine if (host.getCachedEngineId() != null) { return; } if (flutterEngine.getDartExecutor().isExecutingDart()) { // No warning is logged because this situation will happen on every config // change if the developer does not choose to retain the Fragment instance. // So this is expected behavior in many cases. return; } Log.d(TAG, \"Executing Dart entrypoint: \" + host.getDartEntrypointFunctionName() + \", and sending initial route: \" + host.getInitialRoute()); // 如果配置了初始路由，通过natigationChannel 发送初始路由信息 if (host.getInitialRoute() != null) { flutterEngine.getNavigationChannel().setInitialRoute(host.getInitialRoute()); } // 配置dart 入口函数 // flutter_assets , DartExecutor.DartEntrypoint entrypoint = new DartExecutor.DartEntrypoint( host.getAppBundlePath(), host.getDartEntrypointFunctionName() ); // 执行入口函数 flutterEngine.getDartExecutor().executeDartEntrypoint(entrypoint); } 这段代码的逻辑较为简单，如果使用cache Engine 则不执行启动engine，如果配置了初始路由，通过method channel 发送。这也是通过cache engine 启动 flutterActivity 时候没有提供初始路由的选项。 然后后面是构建DartEntrypoint，通过flutterengine 启动。 DartEntrypoint构建 DartExecutor.DartEntrypoint entrypoint = new DartExecutor.DartEntrypoint( host.getAppBundlePath(), host.getDartEntrypointFunctionName() ); 其中host.getAppBundlePath() 默认为 flutter_assets，而host.getDartEntrypointFunctionName() 默认为“main” executeDartEntrypoint （DartExecutor.java） public void executeDartEntrypoint(@NonNull DartEntrypoint dartEntrypoint) { if (isApplicationRunning) { Log.w(TAG, \"Attempted to run a DartExecutor that is already running.\"); return; } Log.v(TAG, \"Executing Dart entrypoint: \" + dartEntrypoint); flutterJNI.runBundleAndSnapshotFromLibrary( dartEntrypoint.pathToBundle, dartEntrypoint.dartEntrypointFunctionName, null, assetManager ); isApplicationRunning = true; } runBundleAndSnapshotFromLibrary public void runBundleAndSnapshotFromLibrary( @NonNull String bundlePath, @Nullable String entrypointFunctionName, @Nullable String pathToEntrypointFunction, @NonNull AssetManager assetManager ) { ensureRunningOnMainThread(); ensureAttachedToNative(); nativeRunBundleAndSnapshotFromLibrary( nativePlatformViewId, bundlePath, entrypointFunctionName, pathToEntrypointFunction, assetManager ); } RunBundleAndSnapshotFromLibrary 在native中nativeRunBundleAndSnapshotFromLibrary 映射成RunBundleAndSnapshotFromLibrary方法。 (flutter/shell/platform/android/platform_view_android_jni.cc) static void RunBundleAndSnapshotFromLibrary(JNIEnv* env, jobject jcaller, jlong shell_holder, jstring jBundlePath, jstring jEntrypoint, jstring jLibraryUrl, jobject jAssetManager) { //创建AssetManager对象 auto asset_manager = std::make_shared(); asset_manager->PushBack(std::make_unique( env, // jni environment jAssetManager, // asset manager fml::jni::JavaStringToString(env, jBundlePath)) // apk asset dir ); std::unique_ptr isolate_configuration; if (flutter::DartVM::IsRunningPrecompiledCode()) { isolate_configuration = IsolateConfiguration::CreateForAppSnapshot(); } else { std::unique_ptr kernel_blob = fml::FileMapping::CreateReadOnly( ANDROID_SHELL_HOLDER->GetSettings().application_kernel_asset); if (!kernel_blob) { FML_DLOG(ERROR) 0) && (libraryUrl.size() > 0)) { config.SetEntrypointAndLibrary(std::move(entrypoint), std::move(libraryUrl)); } else if (entrypoint.size() > 0) { config.SetEntrypoint(std::move(entrypoint)); } } // 启动 ANDROID_SHELL_HOLDER->Launch(std::move(config)); } 这里主要是获取java 传入的入口函数名称以及获取库的地址，然后调用AndroidShellHolder 的Launch 函数。 Launch （flutter/shell/platform/android/android_shell_holder.cc） void AndroidShellHolder::Launch(RunConfiguration config) { if (!IsValid()) { return; } shell_->RunEngine(std::move(config)); } 这里调用RunEngine 函数。 RunEngine （flutter/shell/common/shell.cc） void Shell::RunEngine(RunConfiguration run_configuration) { RunEngine(std::move(run_configuration), nullptr); } void Shell::RunEngine( RunConfiguration run_configuration, const std::function& result_callback) { auto result = [platform_runner = task_runners_.GetPlatformTaskRunner(), result_callback](Engine::RunStatus run_result) { if (!result_callback) { return; } platform_runner->PostTask( [result_callback, run_result]() { result_callback(run_result); }); }; FML_DCHECK(is_setup_); FML_DCHECK(task_runners_.GetPlatformTaskRunner()->RunsTasksOnCurrentThread()); fml::TaskRunner::RunNowOrPostTask( task_runners_.GetUITaskRunner(), fml::MakeCopyable( [run_configuration = std::move(run_configuration), weak_engine = weak_engine_, result]() mutable { if (!weak_engine) { FML_LOG(ERROR) Run(std::move(run_configuration)); if (run_result == flutter::Engine::RunStatus::Failure) { FML_LOG(ERROR) 这里主要是调用Engine 的run 方法 Engine Run 运行 （flutter/shell/common/engine.cc） Engine::RunStatus Engine::Run(RunConfiguration configuration) { ... // 获取入口函数以及library 路径 last_entry_point_ = configuration.GetEntrypoint(); last_entry_point_library_ = configuration.GetEntrypointLibrary(); // 运行isolate auto isolate_launch_status = PrepareAndLaunchIsolate(std::move(configuration)); if (isolate_launch_status == Engine::RunStatus::Failure) { FML_LOG(ERROR) PrepareAndLaunchIsolate （flutter/shell/common/engine.cc） Engine::RunStatus Engine::PrepareAndLaunchIsolate( RunConfiguration configuration) { TRACE_EVENT0(\"flutter\", \"Engine::PrepareAndLaunchIsolate\"); // 更新 asset UpdateAssetManager(configuration.GetAssetManager()); // 获取isolate 配置 auto isolate_configuration = configuration.TakeIsolateConfiguration(); // 获取root isolate std::shared_ptr isolate = runtime_controller_->GetRootIsolate().lock(); .......... if (configuration.GetEntrypointLibrary().empty()) { if (!isolate->Run(configuration.GetEntrypoint(), settings_.dart_entrypoint_args)) { FML_LOG(ERROR) RunFromLibrary(configuration.GetEntrypointLibrary(), configuration.GetEntrypoint(), settings_.dart_entrypoint_args)) { FML_LOG(ERROR) RunFromLibrary （flutter/runtime/dart_isolate.cc） bool DartIsolate::RunFromLibrary(const std::string& library_name, const std::string& entrypoint_name, const std::vector& args, const fml::closure& on_run) { TRACE_EVENT0(\"flutter\", \"DartIsolate::RunFromLibrary\"); if (phase_ != Phase::Ready) { return false; } tonic::DartState::Scope scope(this); // 获取入口函数 auto user_entrypoint_function = Dart_GetField(Dart_LookupLibrary(tonic::ToDart(library_name.c_str())), tonic::ToDart(entrypoint_name.c_str())); // 获取入口函数参数 auto entrypoint_args = tonic::ToDart(args); // 运行入口函数 if (!InvokeMainEntrypoint(user_entrypoint_function, entrypoint_args)) { return false; } phase_ = Phase::Running; FML_DLOG(INFO) InvokeMainEntrypoint 运行入口函数 （flutter/runtime/dart_isolate.cc） static bool InvokeMainEntrypoint(Dart_Handle user_entrypoint_function, Dart_Handle args) { if (tonic::LogIfError(user_entrypoint_function)) { FML_LOG(ERROR) 调用Dart 层_runMainZoned方法 ，传入start_main_isolate_function ，用户入口函数user_entrypoint_function 以及相关参数。 _getStartMainIsolateFunction 而_getStartMainIsolateFunction定义在dart 的SDK 中。 （dart/sdk/lib/_internal/vm/lib/isolate_patch.dart） @pragma(\"vm:entry-point\", \"call\") Function _getStartMainIsolateFunction() { return _startMainIsolate; } @pragma(\"vm:entry-point\", \"call\") void _startMainIsolate(Function entryPoint, List args) { _startIsolate( null, // no parent port entryPoint, args, null, // no message true, // isSpawnUri null, // no control port null); // no capabilities } _getStartMainIsolateFunction函数其实是 _startMainIsolate。而内部是调用 _startIsolate。 _runMainZoned 函数 （flutter/lib/ui/hooks.dart） @pragma('vm:entry-point') void _runMainZoned(Function startMainIsolateFunction, Function userMainFunction, List args) { startMainIsolateFunction((){ runZoned(() { if (userMainFunction is _BinaryFunction) { (userMainFunction as dynamic)(args, ''); } else if (userMainFunction is _UnaryFunction) { (userMainFunction as dynamic)(args); } else { // main 方法 userMainFunction(); } }, onError: (Object error, StackTrace stackTrace) { _reportUnhandledException(error.toString(), stackTrace.toString()); }); }, null); } 这里给startMainIsolateFunction 传入闭包函数以及null。而startMainIsolateFunction就是 上面的 _startMainIsolate。而内部是调用 _startIsolate 。 _startIsolate函数 （dart/sdk/lib/_internal/vm/lib/isolate_patch.dart） @pragma(\"vm:entry-point\", \"call\") void _startIsolate( SendPort parentPort, Function entryPoint, List args, var message, bool isSpawnUri, RawReceivePort controlPort, List capabilities) { // 控制端口不处理消息 if (controlPort != null) { controlPort.handler = (_) {}; // Nobody home on the control port. } if (parentPort != null) { var readyMessage = new List(2); readyMessage[0] = controlPort.sendPort; readyMessage[1] = capabilities; capabilities = null; parentPort.send(readyMessage); } assert(capabilities == null); // 延迟所有用户代码，下次消息循环时候处理。 RawReceivePort port = new RawReceivePort(); port.handler = (_) { port.close(); if (isSpawnUri) { if (entryPoint is _BinaryFunction) { (entryPoint as dynamic)(args, message); } else if (entryPoint is _UnaryFunction) { (entryPoint as dynamic)(args); } else { // 执行入口函数 entryPoint(); } } else { entryPoint(message); } }; // 触发消息handler port.sendPort.send(null); } 其中 entryPoint 是 _runMainZoned 中的闭包。也就是runZone 这段代码。 而 runZone 定义是： R runZoned(R body(), { Map zoneValues, ZoneSpecification zoneSpecification, Function onError, }) 等同于沙箱执行body()代码，其中zoneValue 是沙箱私有数据，zoneSpecification 为拦截器，onError 为错误异常回调。 最终会执行userMainFunction,也就是我们定义的main 方法。 void main() => runApp(MyApp()); 总结 整个Flutter 引擎加载分为两个阶段，分别是准备阶段和启动阶段。准备阶段主要是指FlutterActivity的onCreate方法内，这里主要是进行资源加载以及初始化工作，在java 层进行了静态资源的整合，so库的加载，FlutterEngine等类的创建。在native层，主要进行了相关java 方法的注册关联，而最重要的是创建了AndroidShellHolder对象，而内部也创建了4大线程，以及Shell ，Engine ，DartVM 等重要对象。在准备阶段结束后，执行Activity的onStart 方法，进入启动阶段。这里java 把入口函数等信息封装成DartEntrypoint 对象。 Copyright © david 2019 all right reserved，powered by Gitbook该文件修订时间： 2020-04-28 16:03:24 "},"0-Flutter/8-Flutter Redux简单介绍.html":{"url":"0-Flutter/8-Flutter Redux简单介绍.html","title":"Redux 介绍","keywords":"","body":"Redux 介绍 状态管理框架，源自JS ，React ，中文文档 为什么要用redux 程序复杂带来的问题 状态多 数据源多 变化难控 Flutter 的状态管理 StatefulWidget 其他第三方状态管理框架 ScopedModel，BLoC，Redux，MobX Redux 核心概念 三大原则 单一数据源。 state 只可读。 reducer 为纯函数。 重要角色概念 action 应用（View）层发起的更改意图，只描述事情发生动作，可以为任何对象。 type payload 尽量减少在 action 中传递的数据 reducer 响应action，处理数据并保存新数据到store中。 纯函数 可拆分 (action , state) => state; 根据它们的 key 来筛选出 state 中的一部分数据并处理 store 单一的数据存储器。 维护应用state 提过getstate，获取state 提供dispatch ，更新state 添加监听器，subscribe(listener) middleware 中间件，拦截器。 函数 （stroe）=>dynamic FlutterRedux 中重要的类 StoreProvider const StoreProvider({ Key key, @required Store store, @required Widget child, }) : assert(store != null), assert(child != null), _store = store, super(key: key, child: child); StoreConnector const StoreConnector({ Key key, @required this.builder, @required this.converter, this.distinct = false, this.onInit, this.onDispose, this.rebuildOnChange = true, this.ignoreChange, this.onWillChange, this.onDidChange, this.onInitialBuild, }) : assert(builder != null), assert(converter != null), super(key: key); buidler typedef ViewModelBuilder = Widget Function( BuildContext context, ViewModel vm, ); converter typedef StoreConverter = ViewModel Function( Store store, ); Redux 使用 1. 添加依赖 redux flutter_redux 2. 创建Action enum DemoAction { increment } 3. 创建State ///创建一个State @immutable class DemoState { final int _count; get count => _count; DemoState(this._count); DemoState.initState() { _count = 0; } } 4. 创建Reducer ///创建状态生成器 ///构造一个Store 存储器时候需要传入一个生成器 ///生成器的定义: ///typedef State Reducer(State state, dynamic action); ///本质是一个方法 DemoState reducer(DemoState state, action){ if(action == DemoAction.increment){ return DemoState(state.count+1); } return state; } 5. 创建Store final store = Store(reducer, initialState: DemoState.initState()); 6. 顶层StoreProvider class MyApp extends StatelessWidget { @override Widget build(BuildContext context) { return StoreProvider( store: store, child: MaterialApp( title: 'Flutter Demo', theme: ThemeData( primarySwatch: Colors.blue, ), home: MyHomePage(title: 'Flutter Demo Home Page'), ), ); } } 7. 发起Action floatingActionButton: StoreConnector( converter: (store) { return () => store.dispatch(DemoAction.increment); }, builder: (context, callback) { return FloatingActionButton( onPressed: callback, tooltip: 'Increment', child: Icon(Icons.add), ); }, ) 8. 响应 StoreConnector( converter: (store) => store.state.count, builder: (context, count) { return Text( '$count', style: Theme .of(context) .textTheme .display1, ); }, ) 实际使用 需求： 计数器改造成Redux实现。 一个页面输入信息，另外一个页面获取信息。 原理 StoreProvider class StoreProvider extends InheritedWidget { final Store _store; const StoreProvider({ Key key, @required Store store, @required Widget child, }) : assert(store != null), assert(child != null), _store = store, super(key: key, child: child); ... @override bool updateShouldNotify(StoreProvider oldWidget) => _store != oldWidget._store; } InheritedWidget 原生数据共享Widget，数据从上到下传递。 中文文档 携带共享数据 updateShouldNotify 确认子树是否需要重建。 子树获取Store static Store of(BuildContext context, {bool listen = true}) { final type = _typeOf>(); final provider = (listen ? context.inheritFromWidgetOfExactType(type) : context .ancestorInheritedElementForWidgetOfExactType(type) ?.widget) as StoreProvider; if (provider == null) throw StoreProviderError(type); return provider._store; } inheritFromWidgetOfExactType 子树重构 ancestorInheritedElementForWidgetOfExactType 子树不变化 Store.dispath List _dispatchers; dynamic dispatch(dynamic action) { return _dispatchers[0](action); } 分发器处理动作： class Store { Reducer reducer; final StreamController _changeController; State _state; List _dispatchers; Store( this.reducer, { State initialState, List> middleware = const [], bool syncStream = false, bool distinct = false, }) : _changeController = StreamController.broadcast(sync: syncStream) { _state = initialState; _dispatchers = _createDispatchers( middleware, _createReduceAndNotify(distinct), ); } NextDispatcher _createReduceAndNotify(bool distinct) { return (dynamic action) { //reducer 处理action final state = reducer(_state, action); // 如果distance 为true 而且新的state 与旧的相同 return 处理 if (distinct && state == _state) return; // 更新state _state = state; // 添加到Stream 中 _changeController.add(state); }; } List _createDispatchers( List> middleware, NextDispatcher reduceAndNotify, ) { final dispatchers = []..add(reduceAndNotify); // 转换中间件Middleware为分发器 for (var nextMiddleware in middleware.reversed) { final next = dispatchers.last; dispatchers.add( (dynamic action) => nextMiddleware(this, action, next), ); } return dispatchers.reversed.toList(); } ... } 在创建store 时候: 调用_createReduceAndNotify方法创建一个NextDispatcher分发器， 调用_createDispatchers方法创建一个分发器链。 这里主要把中间件以及reducer 包装成NextDispatcher存储，经过两次reversed后，执行顺序是先中间件list ，再reducer。 所以当执行store.dispath操作后，最终执行_createReduceAndNotify方法内生成的分发器， action 经过reducer 处理获取新的state。 判断state 是否变化（可选）。 更新state。 添加进StreamController 中通知更新。 StoreConnector @override Widget build(BuildContext context) { return _StoreStreamListener( store: StoreProvider.of(context), builder: builder, converter: converter, distinct: distinct, onInit: onInit, onDispose: onDispose, rebuildOnChange: rebuildOnChange, ignoreChange: ignoreChange, onWillChange: onWillChange, onDidChange: onDidChange, onInitialBuild: onInitialBuild, ); } 本质是一个_StoreStreamListener，其中Store 是StoreProvider 全局Store。 _StoreStreamListener class _StoreStreamListenerState extends State> { Stream stream; ViewModel latestValue; @override void initState() { ///执行onInit if (widget.onInit != null) { widget.onInit(widget.store); } /// 执行 onInitialBuild if (widget.onInitialBuild != null) { WidgetsBinding.instance.addPostFrameCallback((_) { widget.onInitialBuild(latestValue); }); } /// state 转换 latestValue = widget.converter(widget.store); /// 初始化流 _createStream(); super.initState(); } ... @override Widget build(BuildContext context) { /// rebuildOnChange 默认为true,返回一个StreamBuilder对象 return widget.rebuildOnChange ? StreamBuilder( stream: stream, builder: (context, snapshot) => widget.builder( context, latestValue, ), ) : widget.builder(context, latestValue); } ... /// 创建Stream，在initState 和didUpdateWidget 中调用 void _createStream() { stream = widget.store.onChange .where(_ignoreChange) .map(_mapConverter) .where(_whereDistinct) .transform(StreamTransformer.fromHandlers(handleData: _handleChange)); } /// 更新viewModel void _handleChange(ViewModel vm, EventSink sink) { if (widget.onWillChange != null) { widget.onWillChange(latestValue, vm); } latestValue = vm; if (widget.onDidChange != null) { ///安全执行onDidChange WidgetsBinding.instance.addPostFrameCallback((_) { widget.onDidChange(latestValue); }); } sink.add(vm); } } 主要流程是： initState 方法中，执行相关回调（onInit，onInitialBuild），创建Stream build 方法中，如果rebuildOnChange true ，返回一个StreamBuilder，否则直接执行widget 的build 方法。 而Stream 的创建是： 获取store 中的StreamControl 执行_ignoreChange 方法，如果设置了ignoreChange 回调则执行 执行_mapConverter 方法，执行设置的converter 方法，把顶层state 转为为相关viewmodel 执行_whereDistinct 方法，如果设置distinct(默认为false),比较新旧viewmodel 执行_handleChange方法，如果设置了onWillChange ，onDidChange 回调则执行 流程图 Copyright © david 2019 all right reserved，powered by Gitbook该文件修订时间： 2020-03-30 10:09:40 "},"Android-old/ArrayList源码学习.html":{"url":"Android-old/ArrayList源码学习.html","title":"ArrayList 源码学习","keywords":"","body":"ArrayList 源码学习 简述 ArrayList部分UML类图为 ArrayList继承AbstractList,实现List、RandomAccess、Cloneable、Serializable接口 List 接口，有增删改查，遍历等功能。 RandomAccess，可随机访问。 Cloneable接口，可被克隆。 源码阅读 构造方法 空构造 public ArrayList() { this.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA; } 这里进行的是存储数据元素的数组transient Object[] elementData;（transient关键字是该变量不参与序列化）初始化为空数组（private static final Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = {};） 初始化容量构造（public ArrayList(int initialCapacity)） 这个构造器也是初始化elementData数组，如果初始容量小于0则抛异常。 public ArrayList(int initialCapacity) { if (initialCapacity > 0) { this.elementData = new Object[initialCapacity]; } else if (initialCapacity == 0) { this.elementData = EMPTY_ELEMENTDATA; } else { throw new IllegalArgumentException(\"Illegal Capacity: \"+ initialCapacity); } } 3.初始化数据构造 这个构造传入一个Collection对象，然后把他转为Object数组赋值给elementData public ArrayList(Collection c) { elementData = c.toArray(); if ((size = elementData.length) != 0) { // c.toArray might (incorrectly) not return Object[] (see 6260652) if (elementData.getClass() != Object[].class) elementData = Arrays.copyOf(elementData, size, Object[].class); } else { // replace with empty array. this.elementData = EMPTY_ELEMENTDATA; } } 添加元素 添加元素一般调用add（）方法，这里以最简单add(E e)方法为例。 public boolean add(E e) { ensureCapacityInternal(size + 1); // Increments modCount!! elementData[size++] = e; return true; } 里面方法很简单，里面调用ensureCapacityInternal（）方法后，把添加的元素放入数组。那ensureCapacityInternal这个方法是干嘛的呢，从字面翻译是确保内置容量（） private void ensureCapacityInternal(int minCapacity) { if (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) { minCapacity = Math.max(DEFAULT_CAPACITY, minCapacity); } ensureExplicitCapacity(minCapacity); } 该方法传入最小容量int值，判断数据是否为空，空的话，比较默认容量DEFAULT_CAPACITY（10）和传入的最小容量大小，取更大的数传入方法ensureExplicitCapacity（minCapacity） private void ensureExplicitCapacity(int minCapacity) { modCount++; // overflow-conscious code if (minCapacity - elementData.length > 0) grow(minCapacity); } 这里出现一个新的成员变量modCount（protected transient int modCount = 0;），该变量在父类中被定义，初始化为0，用来记录list结构修改次数。 从上面看出，先确保传入的最小容量大于elementData数组容量的长度，然后把最小容量minCapacity传入方法grow（） private void grow(int minCapacity) { // overflow-conscious code int oldCapacity = elementData.length; int newCapacity = oldCapacity + (oldCapacity >> 1); if (newCapacity - minCapacity 0) newCapacity = hugeCapacity(minCapacity); // minCapacity is usually close to size, so this is a win: elementData = Arrays.copyOf(elementData, newCapacity); } 这里先获取旧的容量长度，再增长1.5倍（oldCapacity + (oldCapacity >> 1)），如果小于传入的最小容量，则新得容量等于传入的最小容量，如果新的容量大于最大数组大小MAX_ARRAY_SIZE，新容量会等于Integer.MAX_VALUE或者MAX_ARRAY_SIZE。最后把elementData和新容量传入Arrays.copyOf方法。而里面调用重构copyOf方法， public static T[] copyOf(U[] original, int newLength, Class newType) { @SuppressWarnings(\"unchecked\") T[] copy = ((Object)newType == (Object)Object[].class) ? (T[]) new Object[newLength] : (T[]) Array.newInstance(newType.getComponentType(), newLength); System.arraycopy(original, 0, copy, 0, Math.min(original.length, newLength)); return copy; } 可以看出主要还是调用系统的数组拷贝方法进行扩容。 public static native void arraycopy(Object src, int srcPos, Object dest, int destPos, int length); 这个方法的参数分别是原数组，原数组起始位置，目标数组，目标数组起始位置，拷贝的长度。 删除 删除主要调用remove方法，查看源码发现该方法有很多重构，根据索引删除元素，根据对象删除元素。这里吐槽下这bug，当存储的是Integer数据时候，如果想remove 1 对象会调用remove 索引方法。 来看常用的根据索引删除元素方法 public E remove(int index) { if (index >= size) throw new IndexOutOfBoundsException(outOfBoundsMsg(index)); modCount++; E oldValue = (E) elementData[index]; int numMoved = size - index - 1; if (numMoved > 0) System.arraycopy(elementData, index+1, elementData, index, numMoved); elementData[--size] = null; // clear to let GC do its work return oldValue; } 如果索引大于数组长度，抛出个异常。然后记录该位置的元素，然后通过上面熟悉的System.arraycopy方法进行数组移动，再把最后一个元素置为null，接着返回删除的元素 改 更改某个位置元素，通常调用set函数 public E set(int index, E element) { if (index >= size) throw new IndexOutOfBoundsException(outOfBoundsMsg(index)); E oldValue = (E) elementData[index]; elementData[index] = element; return oldValue; } 同样这个方法也比较简单，先判断索引是否越界，然后记录旧元素，赋值新元素，返回旧元素。 查 查看是否有某元素，通常调用contains方法，该方法体比较简单return indexOf(o) >= 0; 我们撸下indexOf源码 public int indexOf(Object o) { if (o == null) { for (int i = 0; i 里面先判断查找元素是否是null（Arryalist可以存储null），然后for循环查找元素，返回其索引，若没有则返回-1. Iterator ArrayList还实现了Iterator迭代器接口，主要有内部的Itr类完成这功能，来撸下迭代器源码。 Itr为ArrayList的内部类,其中重要的方法是hasNext(),next(),remove()。 hasNext() public boolean hasNext() { return cursor 这个方法比较简单，只需明白cursor 和limit两个变量意义。其中cursor是下个返回元素的索引，默认为0。limit是ArrayList的大小。 next() next方法弹出下个元素 public E next() { if (modCount != expectedModCount) throw new ConcurrentModificationException(); int i = cursor; if (i >= limit) throw new NoSuchElementException(); Object[] elementData = ArrayList.this.elementData; if (i >= elementData.length) throw new ConcurrentModificationException(); cursor = i + 1; return (E) elementData[lastRet = i]; } 先进行个判断之前出现的modCount（用于记录ArrayList结构修改的次数），而expectedModCount初始值为modeCount,所以在迭代器循环中如果调用Arraylist的add或remove方法都会抛出异常。后面的逻辑也比较简单，确保索引在范围内，索引改变， return elementData对应元素 remove() remove方法也比较简单，实际是调用ArrayList的remove方法，然后更改索引等变量。 总结 ArrayList内部使用数组存储元素，每次添加元素时候会确保内部容量，容量不够时候进行扩容操作（默认容量为10），扩容系数为1.5（原容量+原容量 Copyright © david 2019 all right reserved，powered by Gitbook该文件修订时间： 2020-04-28 15:08:39 "},"Android-old/Fragmentation 库学习笔记.html":{"url":"Android-old/Fragmentation 库学习笔记.html","title":"Fragmentation 库学习笔记","keywords":"","body":"Fragmentation 库学习笔记 简介 前段时间项目上要使用单Activity+多Fragment结构。Fragmentation这个库极大的方便我们对Fragment进行管理，可轻松进行start，pop，hide，show等操作，而且提供调试工具可轻松查看Fragment栈视图，降低开发难度。具体引入使用可参看上面github链接。下面对这个库进行简单的源码分析。 源码分析 在使用时候我们常常需要继承SupportActivity或者实现ISupportActivity接口，然后在onCreate方法内调用loadRootFragment方法。 if (homeFragment == null) { loadRootFragment(R.id.fl_bottom, getMainFragment() as ISupportFragment) } 现在我们就从这个方法开始入手。 loadRootFragment 1. SupportActivity 中的 loadRootFragment loadRootFragment这个方法做了什么工作呢，看下它的源码 public void loadRootFragment(int containerId, @NonNull ISupportFragment toFragment) { mDelegate.loadRootFragment(containerId, toFragment); } 上面可以看出实际load工作交给mDelegate这个对象做，而这个mDelegate对象又是什么呢？ 我们继续查看。 final SupportActivityDelegate mDelegate = new SupportActivityDelegate(this); 原来mDelegate 是 SupportActivityDelegate ，supportActivity中的ISupportActivity接口的大部分实现工作都交给这个代理类去做。而这个代理类也是这个框架的核心，后面很多分析都会接触到它。 2. SupportActivityDelegate中的loadRootFragment 来看下代理类中的loadRootFragment 方法： public void loadRootFragment(int containerId, ISupportFragment toFragment) { loadRootFragment(containerId, toFragment, true, false); } public void loadRootFragment(int containerId, ISupportFragment toFragment, boolean addToBackStack, boolean allowAnimation) { mTransactionDelegate.loadRootTransaction(getSupportFragmentManager(), containerId, toFragment, addToBackStack, allowAnimation); } emmmmm,果然优秀的框架都是跳来跳去的。可以看到这个方法的实现又又又又交给一个代理去实现具体逻辑。而这个mTransactionDelegate成员变量实际上是TransactionDelegate。这个变量在onCreate()时候被初始化。 public void onCreate(@Nullable Bundle savedInstanceState) { mTransactionDelegate = getTransactionDelegate(); mDebugStackDelegate = new DebugStackDelegate(mActivity); mFragmentAnimator = mSupport.onCreateFragmentAnimator(); mDebugStackDelegate.onCreate(Fragmentation.getDefault().getMode()); } 可以看见onCreate方法内初始化了很多代理。 3. TransactionDelegate 的loadRootTranslation方法 按照惯例，先贴个代码： void loadRootTransaction(final FragmentManager fm, final int containerId, final ISupportFragment to, final boolean addToBackStack, final boolean allowAnimation) { enqueue(fm, new Action(Action.ACTION_LOAD) { @Override public void run() { bindContainerId(containerId, to); String toFragmentTag = to.getClass().getName(); TransactionRecord transactionRecord = to.getSupportDelegate().mTransactionRecord; if (transactionRecord != null) { if (transactionRecord.tag != null) { toFragmentTag = transactionRecord.tag; } } start(fm, null, to, toFragmentTag, !addToBackStack, null, allowAnimation, TYPE_REPLACE); } }); } 这里实际上是把一些操作放入一个队列。 3.1 enqueue 方法 我们先来看下enqueue方法： private void enqueue(FragmentManager fm, Action action) { if (fm == null) { Log.w(TAG, \"FragmentManager is null, skip the action!\"); return; } mActionQueue.enqueue(action); } 里面的操作也很简单，检查fragmentManager 不为空，然后把action对象入列ActionQueue对象中。 而经查看Action类是个抽象类，里面定义一些操作（pop，load，back等）标识常量，以及在上面看下的run抽象方法。 而ActionQueue类也比较简单，里面是一个队列以及主线程的handler。 3.1.1 ActionQueue 的 enqueue方法 主要看下ActionQueue中的入列方法。 public void enqueue(final Action action) { if (isThrottleBACK(action)) return; if (action.action == Action.ACTION_LOAD && mQueue.isEmpty() && Thread.currentThread() == Looper.getMainLooper().getThread()) { action.run(); return; } mMainHandler.post(new Runnable() { @Override public void run() { enqueueAction(action); } }); } 这个方法可以看到，我们提交过来的Action（实际pop，start等对fragment操作）会先检测下action类型和列队中action中的情况，而初始时候这种load的action 是直接执行。 所以load这个动作具体动作还是在loadRootTransaction方法中。里面就进行了两个操作绑定contentId和进行一个start方法。 3.2 bindContainerId方法 来看怎么绑定我们要替换的id： private void bindContainerId(int containerId, ISupportFragment to) { Bundle args = getArguments((Fragment) to); args.putInt(FRAGMENTATION_ARG_CONTAINER, containerId); } 很简单，里面把要替换的view id 通过fragment的 arguments 传递给 目标rootfragment。 3.3 start方法 start是个十分重要的方法，之后分析一些其他动作我们也会看见,下面是它的部分源码： private void start(FragmentManager fm, final ISupportFragment from, ISupportFragment to, String toFragmentTag, boolean dontAddToBackStack, ArrayList sharedElementList, boolean allowRootFragmentAnim, int type) { FragmentTransaction ft = fm.beginTransaction(); boolean addMode = (type == TYPE_ADD || type == TYPE_ADD_RESULT || type == TYPE_ADD_WITHOUT_HIDE || type == TYPE_ADD_RESULT_WITHOUT_HIDE); Fragment fromF = (Fragment) from; Fragment toF = (Fragment) to; Bundle args = getArguments(toF); args.putBoolean(FRAGMENTATION_ARG_REPLACE, !addMode); // 这里处理sharedElement 动画 ... if (from == null) { ft.replace(args.getInt(FRAGMENTATION_ARG_CONTAINER), toF, toFragmentTag); if (!addMode) { ... } } else { ... } if (!dontAddToBackStack && type != TYPE_REPLACE_DONT_BACK) { ft.addToBackStack(toFragmentTag); } supportCommit(fm, ft); } 这个方法相比之前的有点长，参数也有点多。但其实里面所做的事情也比较容易能看懂。判断是否是add模式，进行动画transaction，进行add、hide 或者replace 动作，最后执行supportCommit方法进行事务提交。而对于set loot fragment 动作，from Fragment 为空，所以执行的是 ft.replace(args.getInt(FRAGMENTATION_ARG_CONTAINER), toF, toFragmentTag);。 loadRootFragment这里分析就结束了。我们正常使用Fragment时候常常开启translation 然后进行replace操作，再提交： supportFragmentManager.beginTransaction() .replace(R.id.fl_top, getRootFragment(), getRootFragment().javaClass.simpleName) .commit() 而框架内实际也是进行这样的操作，只是它把我们经常会在Activity做的事情交给SupportActivityDelegate代理执行，而SupportActivityDelegate又把这个动作交给TranslationDelegate类执行。 start Fragment 分析完loadRootFragment方法后，我们再来分析下，Fragment中常用的start方法。 在 ISupportFragment 的实现类中，我们可以这样使用启动一个Fragment start(DetailFragment.newInstance(HomeBean));。 如果你使用Kotlin，我们还可以仿照Anko 进行优化封装（不使用可无视）： 创建内联扩展方法 inline fun AbsSupportFragment.startFragment(vararg param: Pair) = this.start(instanceSupFrg(*param)!!) 其中AbsSupportFragment是实现ISupportFragment接口的Fragment基类 反射创建Fragment对象 /** * 创建fragment */ inline fun instanceSupFrg(vararg param: Pair) = try { val instance = T::class.java.getConstructor().newInstance() if (param.isNotEmpty()){ instance.arguments = Bundle().filterArguments(param) } instance } catch (e: Exception) { LogUtils.e(\"instanceFragment\", e) null } 获取解析传入的参数 arguments @Suppress(\"UNCHECKED_CAST\") fun Bundle.filterArguments(params: Array>): Bundle { params.forEach { val value = it.second when (value) { null -> this.putSerializable(it.first, null as Serializable?) is Int -> this.putInt(it.first, value) is Long -> this.putLong(it.first, value) is CharSequence -> this.putCharSequence(it.first, value) is String -> this.putString(it.first, value) is Float -> this.putFloat(it.first, value) is Double -> this.putDouble(it.first, value) is Char -> this.putChar(it.first, value) is Short -> this.putShort(it.first, value) is Boolean -> this.putBoolean(it.first, value) is Serializable -> this.putSerializable(it.first, value) is Bundle -> this.putBundle(it.first, value) is Parcelable -> this.putParcelable(it.first, value) is Array -> when { value.isArrayOf() -> this.putCharSequenceArray(it.first, value as Array?) value.isArrayOf() -> this.putStringArray(it.first, value as Array?) value.isArrayOf() -> putParcelableArray(it.first, value as Array?) else -> throw AnkoException(\"Intent extra ${it.first} has wrong type ${value.javaClass.name}\") } is Byte -> this.putByte(it.first, value) is ByteArray -> this.putByteArray(it.first, value) is IntArray -> this.putIntArray(it.first, value) is LongArray -> this.putLongArray(it.first, value) is FloatArray -> this.putFloatArray(it.first, value) is DoubleArray -> this.putDoubleArray(it.first, value) is CharArray -> this.putCharArray(it.first, value) is ShortArray -> this.putShortArray(it.first, value) is BooleanArray -> this.putBooleanArray(it.first, value) else -> throw AnkoException(\"Intent extra ${it.first} has wrong type ${value.javaClass.name}\") } } return this } 这部分代码参考Anko 中fillIntentArguments 方法 封装后使用 简单封装后我们可以这样启动Fragment startFragment() startFragment( CameraFaceFragment.ORDER_BEAN to bean, CameraFaceFragment.CHECK_IN_NUMBER to count, CameraFaceFragment.FROM_ORDER to true ) 好了，下面就正式开始分析start 怎么实现的了。 1. SupportFragmentDelegate中的start方法 无论是继承SupportFragment还是实现ISupportFragment 接口，调用Start方法时都是调用代理类（SupportFragmentDelegate）的 start 方法，而里面最终都是运行start 的重载方法： public void start(final ISupportFragment toFragment, @ISupportFragment.LaunchMode int launchMode) { mTransactionDelegate.dispatchStartTransaction(mFragment.getFragmentManager(), mSupportF, toFragment, 0, launchMode, TransactionDelegate.TYPE_ADD); } 而 mTransactionDelegate 变量明显也是代理对象，在onAttach方法内进行初始化： public void onAttach(Activity activity) { if (activity instanceof ISupportActivity) { this.mSupport = (ISupportActivity) activity; this._mActivity = (FragmentActivity) activity; //这里初始化事务代理 mTransactionDelegate = mSupport.getSupportDelegate().getTransactionDelegate(); } else { throw new RuntimeException(activity.getClass().getSimpleName() + \" must impl ISupportActivity!\"); } } 这里可以看见其实 SupportFragmentDelegate 里面的事务代理和 SupportActivityDelegate 其实是同一个对象。 2.TransactionDelegate中dispatchStartTransaction方法 前面接触过Transaction中的loadRootTransaction 方法，现在我们来看下dispatchStartTransaction会简单好多。 void dispatchStartTransaction(final FragmentManager fm, final ISupportFragment from, final ISupportFragment to, final int requestCode, final int launchMode, final int type) { enqueue(fm, new Action(launchMode == ISupportFragment.SINGLETASK ? Action.ACTION_POP_MOCK : Action.ACTION_NORMAL) { @Override public void run() { doDispatchStartTransaction(fm, from, to, requestCode, launchMode, type); } }); } 同样也是构成Action对象放入队列中，同样我们只需要关心run方法的内容，这里把具体实现逻辑放到 doDispatchStartTransaction方法。 private void doDispatchStartTransaction(FragmentManager fm, ISupportFragment from, ISupportFragment to, int requestCode, int launchMode, int type) { checkNotNull(to, \"toFragment == null\"); // 如果start要获取结果 if ((type == TYPE_ADD_RESULT || type == TYPE_ADD_RESULT_WITHOUT_HIDE) && from != null) { // 判断是否attach 到Activity if (!((Fragment) from).isAdded()) { Log.w(TAG, ((Fragment) from).getClass().getSimpleName() + \" has not been attached yet! startForResult() converted to start()\"); } else { // 通过Bundle 存储请求码到from 和 to Fragment中 saveRequestCode(fm, (Fragment) from, (Fragment) to, requestCode); } } // 现在获取顶部Fragment from = getTopFragmentForStart(from, fm); // 获取之前replace的 containerId int containerId = getArguments((Fragment) to).getInt(FRAGMENTATION_ARG_CONTAINER, 0); // 处理栈顶Fragment为空和containerId为空的情况 if (from == null && containerId == 0) { Log.e(TAG, \"There is no Fragment in the FragmentManager, maybe you need to call loadRootFragment()!\"); return; } // 当 containerId 为空时候，放入Fragment 的argument中 if (from != null && containerId == 0) { bindContainerId(from.getSupportDelegate().mContainerId, to); } // process ExtraTransaction String toFragmentTag = to.getClass().getName(); boolean dontAddToBackStack = false; ArrayList sharedElementList = null; TransactionRecord transactionRecord = to.getSupportDelegate().mTransactionRecord; if (transactionRecord != null) { if (transactionRecord.tag != null) { toFragmentTag = transactionRecord.tag; } dontAddToBackStack = transactionRecord.dontAddToBackStack; if (transactionRecord.sharedElementList != null) { sharedElementList = transactionRecord.sharedElementList; // Compat SharedElement FragmentationMagician.reorderIndices(fm); } } // 处理启动模式 if (handleLaunchMode(fm, from, to, toFragmentTag, launchMode)) return; // 实际启动 start(fm, from, to, toFragmentTag, dontAddToBackStack, sharedElementList, false, type); } 这个方法的代码量比之前多，除去处理异常场景，重要逻辑就两个。1. 处理带有类似启动模式的start；2. 调用start 方法实际启动Fragment。 3.1 TransactionDelegate的handleLaunchMode方法 这个方法主要从处理带有启动模式的start private boolean handleLaunchMode(FragmentManager fm, ISupportFragment topFragment, final ISupportFragment to, String toFragmentTag, int launchMode) { if (topFragment == null) return false; final ISupportFragment stackToFragment = SupportHelper.findBackStackFragment(to.getClass(), toFragmentTag, fm); if (stackToFragment == null) return false; if (launchMode == ISupportFragment.SINGLETOP) { if (to == topFragment || to.getClass().getName().equals(topFragment.getClass().getName())) { handleNewBundle(to, stackToFragment); return true; } } else if (launchMode == ISupportFragment.SINGLETASK) { doPopTo(toFragmentTag, false, fm, DEFAULT_POPTO_ANIM); mHandler.post(new Runnable() { @Override public void run() { handleNewBundle(to, stackToFragment); } }); return true; } return false; } 里面逻辑也是很简单。通过TAG名字找到目标fragment，如果是SINGLETOP，检查栈顶fragment是不是要启动的fragment，如果是执行handleNewBundle方法（里面逻辑是更新argument，执行fragment的onNewBundle方法）。如果是SINGLETASK模式，执行doPopTo方法，把目标fragment上面的都移除掉，然后再执行handleNewBundle方法。 3.2 TransactionDelegate的start方法 又回到的了这个方法，之前我们在看 loadRootFragment 时候接触过这个方法，不过很多细节被我们隐藏,不过拆分下去也比较好理解。处理sharedElement动画->处理loadRoot情况->处理正常启动情况->是否添加到回退栈addToBackStack->提交事务。而其中和我们有关的逻辑是： if (addMode) { ft.add(from.getSupportDelegate().mContainerId, toF, toFragmentTag); if (type != TYPE_ADD_WITHOUT_HIDE && type != TYPE_ADD_RESULT_WITHOUT_HIDE) { ft.hide(fromF); } } else { ft.replace(from.getSupportDelegate().mContainerId, toF, toFragmentTag); } 主要根据不同type进行add、hide、replace操作。 pop操作 根据前面的经验，实际操作看TransactionDelegate的pop方法： void pop(final FragmentManager fm) { enqueue(fm, new Action(Action.ACTION_POP, fm) { @Override public void run() { handleAfterSaveInStateTransactionException(fm, \"pop()\"); removeTopFragment(fm); FragmentationMagician.popBackStackAllowingStateLoss(fm); } }); } 里面实际移除的方法是removeTopFragment private void removeTopFragment(FragmentManager fm) { ISupportFragment top = SupportHelper.getBackStackTopFragment(fm); if (top != null) { fm.beginTransaction() .setTransition(FragmentTransaction.TRANSIT_FRAGMENT_CLOSE) .remove((Fragment) top) .commitAllowingStateLoss(); } } 可以看见里面实际上进行remove事务操作。 总结 经过源码学习发现，里面用了很多代理模式，但经过剖析可以大概分成3个部分： 外观类 比如SupportFragment，ISupportFragment，SupportActivity，ISupportActivity，SupportFragmentDelegate，SupportActivityDelegate 这些外观类直接跟使用者接触。 核心类 主要是实际进行事务操作的TransactionDele代理类，以及ActionQueue，Action这些封装操作的类。里面处理了加载根Fragment、替换根Fragment、add/replace 子Fragment、隐藏/显示Fragment、启动Fragment，以及Fragment出栈，获取某Fragment ，处理转场动画等操作。 帮助类 主要是一些DebugStackDelegate，SupportHelper，异常处理类，动画类等。 Copyright © david 2019 all right reserved，powered by Gitbook该文件修订时间： 2020-04-28 15:09:24 "},"Android-old/HashMap源码学习.html":{"url":"Android-old/HashMap源码学习.html","title":"HashMap 源码学习笔记","keywords":"","body":"HashMap 源码学习笔记 前面我们撸了List的源码，接着本想撸个Set的源码，无论是HashSet还是TreeSet里面都有个内置的Map。所以先来撸个Map的源码。 hashMap 构造做了什么事 hashMap 使用什么存储元素 hashMap 怎么添加元素 hashMap 如何删除元素 hashMap 如何实现扩容 hashMap构造 HashMap有4个构造: 空构造HashMap() public HashMap() { this.loadFactor = DEFAULT_LOAD_FACTOR; // all other fields defaulted } 里面进行loadFactor成员变量初始化,而loadFactor是什么呢。在后面的阅读中会发现这个成员变量很常见，它是负载系数，默认为0.75。在扩容时候我们将知道这个变量的作用。 传入初始容量构造 public HashMap(int initialCapacity) { this(initialCapacity, DEFAULT_LOAD_FACTOR); } 这里主要把初始容量以及默认的负载系数传入第三个构造 初始容量，负载系数构造 public HashMap(int initialCapacity, float loadFactor) { if (initialCapacity MAXIMUM_CAPACITY) initialCapacity = MAXIMUM_CAPACITY; if (loadFactor 里面逻辑也比较简单，先对传入的初始容量以及加载系数进行判断限制，然后是成员变量赋值。但这里我们看到一个新的成员变量，threshold，阀值，而它是通过tableSizeFor方法确定的，来我们撸下这个方法 static final int tableSizeFor(int cap) { int n = cap - 1; n |= n >>> 1; n |= n >>> 2; n |= n >>> 4; n |= n >>> 8; n |= n >>> 16; return (n = MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + 1; } 看到这就有点蛋疼，这里出现了两个位运算符号>>>（无符号右移）、|=(或等)。我们举几个数来看看这段代码的逻辑，当传入0时候，n=-1，转成2进制有如下步骤 绝对值转为二进制 0000 0001 反码 1111 1110 反码+1 ，1111 1111 所以以 n>>>1 为 0111 1111 1111 1111 1111 1111 1111 1111（负数有符号右移1补位，无符号0补位），|=后 高位又为1，最终为1111 1111 ... 1111 （十进制为-1），经过后面几个步骤最终还是-1 ，最终返回1。而对于正数，这几个步骤的作用是把最高位后面都置为了1，然后加1返回。比如传入的20，n就为19，二进制 0001 0011，经过n |= n >>> 1;得到0001 1011，然后经过n |= n >>> 2得到0001 1111 ，然后之后的步骤 n 都为 31，最终返回32，所以可以传入容量x，2^m-1 传入其他map 这个构造传入了其他map public HashMap(Map m) { this.loadFactor = DEFAULT_LOAD_FACTOR; putMapEntries(m, false); } 而这里也是初始化负载系数，然后调用putMapEntries方法，而putMapEntries就是存放方法。放到后面解析。 HashMap 存储内部类 HashMap中实际存储元素内部类为Node节点，与LinkedList中的节点不同的是，HashMap中的节点是单链表，只记录下个节点next static class Node implements Map.Entry { final int hash; final K key; V value; Node next; Node(int hash, K key, V value, Node next) { this.hash = hash; this.key = key; this.value = value; this.next = next; } public final K getKey() { return key; } public final V getValue() { return value; } public final String toString() { return key + \"=\" + value; } .... .... } 除了上面介绍的next属性，它还有3个比较重要的属性，hash值，存储的key值，以及value值。 而在HashMap中还有个重要的属性transient Node[] table;，一个由上述节点Node组成的数组。所以HashMap中的存储结构其实是数组+链表，既有数组的查找优势，又有链表的增删优势。 HashMap添加元素 我们一般添加元素都是调用put方法，来撸下put方法内做了什么事情。 public V put(K key, V value) { return putVal(hash(key), key, value, false, true); } 发现里面先调用hash方法计算key的hash值再调用putVal方法存放元素。 hash 方法计算hash值 Copyright © david 2019 all right reserved，powered by Gitbook该文件修订时间： 2020-04-28 15:10:20 "},"Android-old/JVM学习笔记.html":{"url":"Android-old/JVM学习笔记.html","title":"JVM 学习笔记","keywords":"","body":"JVM 学习笔记 内存模型 先祭出一张经典的内存结构图 其中内存区域中虚拟机栈（VM stack）,本地方法栈（Native Method Stack），程序计数器（Program Counter Register）是线程私有， 方法区（Method Area），堆（Heap）为线程共有。 程序计数器 主要作用是记录当前线程执行的字节码行号，分支、循环、异常、线程恢复等很多功能都依赖它来完成。如果该线程正在执行java方法，这个计数器记录字节码指令地址，而执行Native方法时候，程序计数器的值为空（Undefined）。 Java虚拟机栈 描述Java方法执行内存的模型。 该区域线程私有。每个线程创建都会创建出相应的栈（VM stack）,它存储了局部变量，方法出口，动态链接等信息。而一个方法的调用到执行完成就是对应一个栈帧在VM stack中入栈到出栈的过程。 而局部变量表存放基本数据类型以及对象引用类型（reference 类型），以及记录字节码指令地址（returnAddress类型）。 可抛出StackOverFlow、OutOfMemory异常。 本地方法栈 同java虚拟机栈，不同的是记录的native方法 Java堆 Java虚拟机中内存最大的部分，该区域的特点是： 线程共享 存储对象实例以及数组 垃圾回收机制主要管理区域 物理内存空间不连续 无内存空间且无法扩展时候抛出OOM 方法区 存储被虚拟机加载的类信息，常量，静态变量等数据。和Java堆一样被线程共享，可动态扩展，无内存且无法扩展时候也抛出OOM。垃圾回收一般很难触及此区域。主要是常量池回收和类的卸载。 运行时常量池 方法区的一部分，存储编译时生成的字面量和符号引用。不同于Class文件常量池，该区域具有动态性，存储的常量不要求一定要编译时期产生。运行时也能把新的常量放入池中。 直接内存 不是虚拟机运行时数据区中的一部分。在NIO中（jdk1.4后引入），使用Native函数直接分配堆外内存，然后通过java堆中DirecByteBuffer对象管理 垃圾回收 垃圾回收机制主要针对Java堆(Heap)和方法区(Method Area),而虚拟机栈等线程私有区域随着线程销毁而被回收所以不参与垃圾回收。 一个对象是否可以被回收 垃圾回收要做的第一件事就是确定对象的存活情况， 引用计数算法 给对象添加一个引用计数器，每当对象被一个地方引用就加一，引用失效时候则减一。 优点是：实现简单，判断效率高。 缺点是：两个对象互相引用时候，GC无法回收 可达性分析算法 以GCRoots对象作为起始点,向下搜索,能够到达的对象都是可达的,证明引用链(Reference Chain)上的对象可用。反之证明不可用。在Java中能够作为GCRoots对象的有， 虚拟机栈中引用的对象 方法区中静态属性引用的对象 方法区中常量引用的对象 本地方法栈中引用的对象 引用概念 无论引用计数法还是可达性分析算法，判断对象是否可用都和引用的概念有关。JDK1.2之前，java引用的定义（reference类型数据指向的内存起始地址，这块内存代表一个引用）只有被引用和没有引用区分。为了丰富引用，进行了扩充： 强引用（Strong Reference） 只要强引用存在，永远不会回收掉被引用的对象 软引用（Soft Reference） 有用但并非必需的对象，内存溢出前将会回收对象 Object obj = new Object(); SoftReference sf = new SoftReference(obj); obj = null; sf.get(); 弱引用（Weak Reference） 非必需对象，存活到下次GC前 Object obj = new Object(); WeakReference wf = new WeakReference(obj); obj = null; wf.get(); wf.isEnQueued(); 虚引用 （Phantom Reference） 无法通过虚引用来获取一个对象实例。为一个对象设置虚引用的目的是当这个对象被系统回收时候得到一个通知。 Object obj = new Object(); PhantomReference pf = new PhantomReference(obj); obj=null; pf.get(); pf.isEnQueued(); 对象死亡过程 一个对象死亡要经历两次标记过程： 没有与GCRoots对象的引用链，被标记第一次。 分析是否有必要执行finalize方法（当该方法没有被覆盖或者被判断没被调用过则被判定没必要执行），如果有必要执行则放入队列，由Finalizer线程执行。 执行finalize方法，如果再无与GCRoots的引用链，被标记第二次然后被回收。 方法区对象的回收 方法区的回收机率较小，主要是废弃常量和无用的类。 废弃常量回收 无任何对象引用了常量池中某个常量，当发生内存回收而且有必要的话，这个常量将被清理。 无用的类回收 无用的类筛选条件 - Java堆中不存在该类的实例 - 加载该类的ClassLoader对象被回收 - 对应的java.lang.Class 对象没被引用 可以通过 -Xnoclassgc 参数来控制是否对类进行卸载。 垃圾回收算法 标记-清除 垃圾回收的基础算法，整个过程分为标记和清除两个阶段。第一阶段经过可达性分析后进行对象标记，第二阶段对标记可回收的对象进行清除。 这个算法的缺点是，1标记和清除两个过程效率低。2，容易产生空间碎片。 标记-整理 同标记-清除算法，在清除后把剩下的对象往后面移动。 这个算法虽然不会产生空间碎片，但同样效率较低 复制 解决了标记的效率问题。把内存均分两部分，每次使用其中一部分，当一块内存用完把这块存活的对象复制到另外一块上，然后清空这块区域。 优点是不产生碎片以及效率高，但内存利用率低，当大多数对象存活时候，复制的效率也低。 分代 现在商用虚拟机常用算法，根据对象的生存时间把内存分为几块。一般把Java堆划分新生代和老年代。新生代使用复制算法，老年代使用标记-清除或者标记-整理算法。 当对象较大或者长时间存活时放入老年代否则放入Eden区域。 而新生代的复制算法经过改进。不是均分两个区域。而是划分出一个较大的Eden和两个相等较小的Survivor区域，回收时把Eden和Survivor存活对象复制到另一块Survivor区域。 垃圾收集器 内存分配以及回收策略 GC触发条件 类加载机制 Copyright © david 2019 all right reserved，powered by Gitbook该文件修订时间： 2020-04-28 15:10:41 "},"Android-old/LinkedList源码学习.html":{"url":"Android-old/LinkedList源码学习.html","title":"LinkedList 学习笔记","keywords":"","body":"LinkedList 学习笔记 简述 LinkList继承AbstractSequentialList类（AbstractSequentialList父类和ArrayList相同也是AbstractList），实现List、Deque（队列）、Cloneable、Serializable接口。 源码阅读 构造方法 有两个构造方法，一个空构造，一个是传入一个Collection对象 public LinkedList(Collection c) { this(); addAll(c); } 其中this（）第一个空构造，里面空实现。主要调用addAll方法,这个方法我们后续再分析。 Node Node为LinkedList的内部类，源码也比较简单，里面3个成员变量分别记录元素，上个节点，下个节点 private static class Node { E item; Node next; Node prev; Node(Node prev, E element, Node next) { this.item = element; this.next = next; this.prev = prev; } } 增 增加元素有很多方法，先分析最简单的add方法 其源码是 public boolean add(E e) { linkLast(e); return true; } 里面调用linkLast方法，从字面理解是吧新增的元素链接到最后，来看下它的源码 void linkLast(E e) { final Node l = last; final Node newNode = new Node<>(l, e, null); last = newNode; if (l == null) first = newNode; else l.next = newNode; size++; modCount++; } 从上面代码可以看出，把新增的元素包装成Node（其头节点指向链表原尾节点，尾节点为null）。而这里出现first，last两个成员变量。分别记录这个链表（LinkedList的头节点和尾节点）。当尾节点为空时候，赋值给头节点，否则添加到尾节点。然后修改链表长度size以及链表结构修改次数modCount 而当该LinkedList走空构造添加第一个元素时候，last（transient Node last;）初始为null，所以链表的头结点为null add(int index, E element) 根据索引添加元素 public void add(int index, E element) { checkPositionIndex(index); if (index == size) linkLast(element); else linkBefore(element, node(index)); } 先确保传入的索引在0，size之间，再判断如果索引是链表长度，直接添加到最后，否则添加到该索引之前。先来分析node（index）方法，该方法应该是根据索引获取节点元素。 Node node(int index) { // assert isElementIndex(index); if (index > 1)) { Node x = first; for (int i = 0; i x = last; for (int i = size - 1; i > index; i--) x = x.prev; return x; } } 先判断传入的索引更靠近头还是尾（size>>1），然后选择从头或者从尾遍历元素，不断取下个（next）或者上个（prev），只到取到索引对应元素并返回 addAll() addAll有两个重构方法，我们直接看传入添加索引和集合的方法。 public boolean addAll(int index, Collection c) { checkPositionIndex(index); Object[] a = c.toArray(); int numNew = a.length; if (numNew == 0) return false; Node pred, succ; if (index == size) { succ = null; pred = last; } else { succ = node(index); pred = succ.prev; } for (Object o : a) { @SuppressWarnings(\"unchecked\") E e = (E) o; Node newNode = new Node<>(pred, e, null); if (pred == null) first = newNode; else pred.next = newNode; pred = newNode; } if (succ == null) { last = pred; } else { pred.next = succ; succ.prev = pred; } size += numNew; modCount++; return true; } 代码比较长，又看见我们熟悉的方法checkPositionIndex（index）检查索引是否在范围内。然后把传入的集合转为数组，确保数组内有元素（if (numNew == 0)return false;）。 接下就是实际添加集合操作。先创建两个节点pred，succ。然后初始化pred（它作用相当于指针）。主要是先判断索引是不是最尾端，如果是指向last也就是链表的尾节点，如果不是通过node（indext）找到对应的插入位置的节点并赋值给succ，然后它的上个节点赋值给pred。 接下就是实际添加元素进链表操作。。。。。。 遍历数组元素，创建节点对象。指针（pred）下移动（pred.next = newNode; pred = newNode）,然后如果succ不为空（当插入位置为最尾端时候succ会为空，此时更改成员变量last），进行闭合链表操作。然后进行更新链表大小以及modCount。 删 LinkedList删除元素的方法有很多,pop(),remove()等。这里只分析几个。 removeFirst（） 这个方法都被pop（），和remove（）方法内部调用。 public E removeFirst() { final Node f = first; if (f == null) throw new NoSuchElementException(); return unlinkFirst(f); } 内部先取出链表头节点，确保它不为空。然后调用unlinkFirst方法 private E unlinkFirst(Node f) { // assert f == first && f != null; final E element = f.item; final Node next = f.next; f.item = null; f.next = null; // help GC first = next; if (next == null) last = null; else next.prev = null; size--; modCount++; return element; } 这里主要是先取出包装在节点中的元素，以及取出其下个节点。然后手动把节点包装元素以及下个节点置为null。把链表的头节点指针（first）指向刚取出的next节点。最后修改size，modCount参数，返回删除的元素。 remove（int index） 里面主要调用unlink（node（index））方法，node（index）之前分析过主要是获取该索引的节点，所以我们重点放到方法unlink上。这个方法主要是分离节点。具体分析见注释。 E unlink(Node x) { // assert x != null; //取出存储的元素 final E element = x.item; //该节点下个节点 final Node next = x.next; //取出该节点的上个节点 final Node prev = x.prev; //确保改节点不是链表头节点(头节点的上节点为null) if (prev == null) { //头节点下移 first = next; } else { //上节点的下指针指向下节点(断开上节点与传入节点关联) prev.next = next; x.prev = null; } //确保节点不是链表尾节店 if (next == null) { last = prev; } else { //断开下节点与传入节点关联 next.prev = prev; x.next = null; } //置为空,方便GC x.item = null; //更改链表大小 size--; //记录结构被修改 modCount++; return element; } 改 改主要调用set方法。源码逻辑也比较简单，取出索引位置节点，更改节点记录的元素值为传入的新值。 public E set(int index, E element) { checkElementIndex(index); Node x = node(index); E oldVal = x.item; x.item = element; return oldVal; } 查 主要是方法contains方法，内部是调用indexOf方法。 public int indexOf(Object o) { int index = 0; if (o == null) { for (Node x = first; x != null; x = x.next) { if (x.item == null) return index; index++; } } else { for (Node x = first; x != null; x = x.next) { if (o.equals(x.item)) return index; index++; } } return -1; } 无论元素是不是null，里面基本是从链表头节点遍历下去，判断节点中存储的元素是否是传入的元素，然后返回索引。 Copyright © david 2019 all right reserved，powered by Gitbook该文件修订时间： 2020-04-28 15:11:03 "},"Android-old/Okhttp源码学习.html":{"url":"Android-old/Okhttp源码学习.html","title":"Okhttp 学习笔记","keywords":"","body":"Okhttp 学习笔记 基本使用 无论是是post还是get请求,基本是如下4步: 建立一个OkHttpClient对象(包含协议路由,拦截器等信息)。 创建Request对象，指定请求url和参数等。 通过client创建call对象（newCall方法） call执行同步或者异步方法 示例代码： OkHttpClient client = new OkHttpClient(); RequestBody body = RequestBody.create(JSON, json); Request request = new Request.Builder() .url(url) .post(body) .build(); Response response = client.newCall(request).execute()); 基本流程 源码分析: client.newcall方法获取的是一个RealCall对象。 /** * Prepares the {@code request} to be executed at some point in the future. */ @Override public Call newCall(Request request) { return new RealCall(this, request, false /* for web socket */); } 2.实际执行的是RealCall方法的execute方法 @Override public Response execute() throws IOException { synchronized (this) { if (executed) throw new IllegalStateException(\"Already Executed\"); executed = true; } captureCallStackTrace(); try { client.dispatcher().executed(this); Response result = getResponseWithInterceptorChain(); if (result == null) throw new IOException(\"Canceled\"); return result; } finally { client.dispatcher().finished(this); } } 其中逻辑是先判断是否被执行。没有执行调用client中的调度器执行，通过getResponseWithInterceptorChain方法获取响应结果。 3.getResponseWithInterceptorChain方法主要内容是 Response getResponseWithInterceptorChain() throws IOException { // Build a full stack of interceptors. List interceptors = new ArrayList<>(); interceptors.addAll(client.interceptors()); interceptors.add(retryAndFollowUpInterceptor); interceptors.add(new BridgeInterceptor(client.cookieJar())); interceptors.add(new CacheInterceptor(client.internalCache())); interceptors.add(new ConnectInterceptor(client)); if (!forWebSocket) { interceptors.addAll(client.networkInterceptors()); } interceptors.add(new CallServerInterceptor(forWebSocket)); Interceptor.Chain chain = new RealInterceptorChain( interceptors, null, null, null, 0, originalRequest); return chain.proceed(originalRequest); } 主要逻辑是，把自定义的拦截器以及内置的BridgeInterceptor、CacheInterceptor、ConnectInterceptor、CallServerInterceptor等拦截器添加进集合构建RealInterceptorChain对象再执行它的proceed方法。 这里给我们留下疑问：1、RealInterceptorChain是啥2、那些内置的拦截器的作用 4.RealInterceptorChain中proceed方法 public Response proceed(Request request, StreamAllocation streamAllocation, HttpCodec httpCodec, Connection connection) throws IOException { if (index >= interceptors.size()) throw new AssertionError(); calls++; // If we already have a stream, confirm that the incoming request will use it. if (this.httpCodec != null && !sameConnection(request.url())) { throw new IllegalStateException(\"network interceptor \" + interceptors.get(index - 1) + \" must retain the same host and port\"); } // If we already have a stream, confirm that this is the only call to chain.proceed(). if (this.httpCodec != null && calls > 1) { throw new IllegalStateException(\"network interceptor \" + interceptors.get(index - 1) + \" must call proceed() exactly once\"); } // Call the next interceptor in the chain. RealInterceptorChain next = new RealInterceptorChain( interceptors, streamAllocation, httpCodec, connection, index + 1, request); Interceptor interceptor = interceptors.get(index); Response response = interceptor.intercept(next); // Confirm that the next interceptor made its required call to chain.proceed(). if (httpCodec != null && index + 1 去除中间判断逻辑,主要内容是构建next RealInterceptorChain(里面拦截器索引+1)对象,然后调用拦截器intercept的intercept方法 5.拦截器的intercept方法 Interceptor是接口,以一个它具体实现类BridgeInterceptor为例。intercept方法接受一个chain对象，也就是之前创建的RealInterceptorChain对象，里面逻辑是取出请求Request,经过处理后，传入chain中得到响应Response 然后经过处理后再返回。 整个流程就是请求--拦截器1处理请求--拦截器2处理请求--.....--拦截器2处理响应--拦截器2处理响应--响应，这是经典的责任链设计模式。 其中内置的拦截器有， RetryAndFollowUpInterceptor(重试，重定向拦截器) BridgeInterceptor（桥接拦截器，转换网络请求，添加头部信息） CacheInerceptor（缓存拦截器） ConnectInerceptor（连接拦截器，主要连接服务器，http，https包装） CallServerInterceptor（服务拦截器,主要负责数据发送，读取） OkHttpClient 其中重要的就是Builder内部类 主要要构建的参数有： Dispatcher dispatcher; //代理 ， 直连接，http，socket Proxy proxy; List protocols; List connectionSpecs; final List interceptors = new ArrayList<>(); final List networkInterceptors = new ArrayList<>(); ProxySelector proxySelector; CookieJar cookieJar; Cache cache; InternalCache internalCache; SocketFactory socketFactory; SSLSocketFactory sslSocketFactory; CertificateChainCleaner certificateChainCleaner; HostnameVerifier hostnameVerifier; CertificatePinner certificatePinner; Authenticator proxyAuthenticator; Authenticator authenticator; ConnectionPool connectionPool; Dns dns; boolean followSslRedirects; boolean followRedirects; boolean retryOnConnectionFailure; int connectTimeout; int readTimeout; int writeTimeout; int pingInterval; 其中在Builder的构造函数内： public Builder() { //请求分发器，内部是有ThreadPoolExecutor dispatcher = new Dispatcher(); // 协议列表，默认为http1.1和http2.0 protocols = DEFAULT_PROTOCOLS; //连接规范列表（TLS等） connectionSpecs = DEFAULT_CONNECTION_SPECS; //线路选择器 proxySelector = ProxySelector.getDefault(); cookieJar = CookieJar.NO_COOKIES; socketFactory = SocketFactory.getDefault(); hostnameVerifier = OkHostnameVerifier.INSTANCE; certificatePinner = CertificatePinner.DEFAULT; proxyAuthenticator = Authenticator.NONE; authenticator = Authenticator.NONE; connectionPool = new ConnectionPool(); //DNS解析 dns = Dns.SYSTEM; followSslRedirects = true; followRedirects = true; retryOnConnectionFailure = true; connectTimeout = 10_000; readTimeout = 10_000; writeTimeout = 10_000; pingInterval = 0; } Request类 也是采用Builder设计模式，好处是可以把复杂对象的构建过程隐藏，解耦和拓展方便。 HttpUrl url; String method; Headers.Builder headers; RequestBody body; Object tag; public Builder() { this.method = \"GET\"; this.headers = new Headers.Builder(); } 主要是请求url，请求方法，请求头，请求体的构建 RealCall 实际访问类。实现Call接口，而Call接口主要方法有 request（）返回Request请求对象 execute同步执行方法 enqueue异步回调方法 cancel终止方法 isExecute判断是否执行 isCanceled判断是否终止 clone克隆方法 而其实现类RealCall中重要的方法就是execute和enqueue，同步、异步获取响应。 同步的情况在上面分析过，下面重点解析异步情况 @Override public void enqueue(Callback responseCallback) { synchronized (this) { if (executed) throw new IllegalStateException(\"Already Executed\"); executed = true; } captureCallStackTrace(); client.dispatcher().enqueue(new AsyncCall(responseCallback)); } 由上面的代码逻辑主要是判断这个call是否被执行，如果被执行抛出异常，然后调用方法captureCallStackTrace()，这个方法主要追踪调用信息，实际上把回调包装成AsyncCall对象交给Dispatcher执行，而实际上AsyncCall是Runnable对象，而dispatcher里面是线程池，执行run方法时调用AsyncCall里的execute方法。 @Override protected void execute() { boolean signalledCallback = false; try { Response response = getResponseWithInterceptorChain(); if (retryAndFollowUpInterceptor.isCanceled()) { signalledCallback = true; responseCallback.onFailure(RealCall.this, new IOException(\"Canceled\")); } else { signalledCallback = true; responseCallback.onResponse(RealCall.this, response); } } catch (IOException e) { if (signalledCallback) { // Do not signal the callback twice! Platform.get().log(INFO, \"Callback failure for \" + toLoggableString(), e); } else { responseCallback.onFailure(RealCall.this, e); } } finally { client.dispatcher().finished(this); } } 里面逻辑一样，调用getResponseWithInterceptorChain获取响应结果，然后进行回调 拦截器分析 RetryAndFollowUpInterceptor 重试及重定向拦截器。重点方法intercept（） （源码略） 主要逻辑是 构建StreamAllocation对象（传递连接池connectionPool以及地址createAddress）。 streamAllocation = new StreamAllocation( client.connectionPool(), createAddress(request.url()), callStackTrace); 开启while 死循环 调用下个拦截器获取响应结果 response = ((RealInterceptorChain) chain).proceed(request, streamAllocation, null, null); 异常捕获，判断请求是否进行 判断是否进行重定向 Request followUp = followUpRequest(response); 关闭响应 closeQuietly(response.body()); 而主要重试及重定向在followUpRequest中完成，处理的返回码为： 407（需要代理授权） 401(未授权) 307，308 临时重定向 300(多种选择)，301(永久移动)，302(临时移动)，303(查看其他位置) BridgeInterceptor 桥接拦截器，主要功能： 处理请求头，若没设置则使用默认配置 调用下个拦截器 对响应进行gzip，header，cookie处理 ConnectInterceptor 连接拦截器 @Override public Response intercept(Chain chain) throws IOException { RealInterceptorChain realChain = (RealInterceptorChain) chain; Request request = realChain.request(); StreamAllocation streamAllocation = realChain.streamAllocation(); // We need the network to satisfy this request. Possibly for validating a conditional GET. boolean doExtensiveHealthChecks = !request.method().equals(\"GET\"); HttpCodec httpCodec = streamAllocation.newStream(client, doExtensiveHealthChecks); RealConnection connection = streamAllocation.connection(); return realChain.proceed(request, streamAllocation, httpCodec, connection); } 里面代码少，但逻辑较为复杂。主要是获取第一个拦截器（RetryAndFollowUpInterceptor）创建的StreamAllocation对象，然后调用它的newStream方法，里面进行创建连接等操作，然后获取连接对象（RealConnection）传递到下个拦截器。 其中主要方法streamAllocation.newStream(client, doExtensiveHealthChecks);主要涉及的类有，StreamAllocation（allocation：分配）、ConnectionPool、RealConnection 1.streamAllocation.newStream(client, doExtensiveHealthChecks);方法返回一个HttpCodec，http编解码器，主要是RealConnection中newCodec方法获取，返回Http1Codec或者Http2Codec 里面重要逻辑调用获取健康的连接方法RealConnection resultConnection = findHealthyConnection(connectTimeout, readTimeout, writeTimeout, connectionRetryEnabled, doExtensiveHealthChecks); 而findHealthyConnection方法主要是调用findConnection方法。 2.findConnection方法 该方法里面逻辑较为复杂，梳理为：当前是否有连接（this.connection对象），有返回，没有则查看连接池（this.connectionPool）是否有连接（Internal.instance.get(connectionPool, address, this);里面从连接池中根据address获取），有返回，没有创建一个连接（result = new RealConnection(connectionPool, selectedRoute);对象），让其与当前连接关联（调用acquire方法），再添加改连接进连接池等操作 而真正的连接方法是调用RealConnection对象的connect方法 // Do TCP + TLS handshakes. This is a blocking operation. result.connect(connectTimeout, readTimeout, writeTimeout, connectionRetryEnabled); routeDatabase().connected(result.route());` 3.RealConnection的connect方法 省略部分代码，核心代码是 ... if (route.requiresTunnel()) { connectTunnel(connectTimeout, readTimeout, writeTimeout); } else { connectSocket(connectTimeout, readTimeout); } ... 如果是https则调用connectTunnel连接通道方法，不是则连接socket 3.1 connectSocket方法 private void connectSocket(int connectTimeout, int readTimeout) throws IOException { Proxy proxy = route.proxy(); Address address = route.address(); rawSocket = proxy.type() == Proxy.Type.DIRECT || proxy.type() == Proxy.Type.HTTP ? address.socketFactory().createSocket() : new Socket(proxy); rawSocket.setSoTimeout(readTimeout); try { Platform.get().connectSocket(rawSocket, route.socketAddress(), connectTimeout); } catch (ConnectException e) { ConnectException ce = new ConnectException(\"Failed to connect to \" + route.socketAddress()); ce.initCause(e); throw ce; } source = Okio.buffer(Okio.source(rawSocket)); sink = Okio.buffer(Okio.sink(rawSocket)); } 里面获取socket对象用OkIo保存输入输出流 3.2 connectTunnel方法 里面也嗲用connectSocket方法，但多了创建隧道方法（createTunnel(readTimeout, writeTimeout, tunnelRequest, url);） （todo 理解隧道） 回到拦截器中streamAllocation.connection();就是返回上面提到的RealConnection 补充知识点Okio Okio 中有两个关键的接口，一个是Sink（可认为是OutputStream的升级版），一个是Source（可认为是InputStream的升级版） Okio子类介绍。BufferedXXX为带有缓冲区功能的子类，而其真正实现类为RealBufferedXXX；GzipXXX是支持gzip功能的实现类 CallServerInterceptor 请求服务拦截器,在自定义网络拦截器之后执行,是最里面的一个拦截器。这个拦截器主要进行数据读写操作。 里面主要进行如下操作 获取之间之前创建的HttpCodec，StreamAllocation，request等信息。 RealInterceptorChain realChain = (RealInterceptorChain) chain; HttpCodec httpCodec = realChain.httpStream(); StreamAllocation streamAllocation = realChain.streamAllocation(); RealConnection connection = (RealConnection) realChain.connection(); Request request = realChain.request(); 写入请求头信息（sink流中） realChain.eventListener().requestHeadersStart(realChain.call()); httpCodec.writeRequestHeaders(request); realChain.eventListener().requestHeadersEnd(realChain.call(), request); httpCodec有两个实现类一个是Http1Codec,另外一个是Http2Codec，下面贴出Http1Codec具体写入请求头 @Override public void writeRequestHeaders(Request request) throws IOException { String requestLine = RequestLine.get( request, streamAllocation.connection().route().proxy().type()); writeRequest(request.headers(), requestLine); } /** Returns bytes of a request header for sending on an HTTP transport. */ public void writeRequest(Headers headers, String requestLine) throws IOException { if (state != STATE_IDLE) throw new IllegalStateException(\"state: \" + state); sink.writeUtf8(requestLine).writeUtf8(\"\\r\\n\"); for (int i = 0, size = headers.size(); i } 判断是否有请求体，有则执行如下逻辑 if (HttpMethod.permitsRequestBody(request.method()) && request.body() != null) 如果请求头包含100-continue（http://www.ituring.com.cn/article/130844），询问服务器是否接受这个请求（服务器接受回应100 continue 拒绝回应 417 expectation failed ） if (\"100-continue\".equalsIgnoreCase(request.header(\"Expect\"))) { httpCodec.flushRequest(); realChain.eventListener().responseHeadersStart(realChain.call()); responseBuilder = httpCodec.readResponseHeaders(true); } 当服务器100-continue响应成功或者不需要等待响应时（客户端不能无限期等待响应）写入请求体 if (responseBuilder == null) { // Write the request body if the \"Expect: 100-continue\" expectation was met. realChain.eventListener().requestBodyStart(realChain.call()); long contentLength = request.body().contentLength(); CountingSink requestBodyOut = new CountingSink(httpCodec.createRequestBody(request, contentLength)); BufferedSink bufferedRequestBody = Okio.buffer(requestBodyOut); request.body().writeTo(bufferedRequestBody); bufferedRequestBody.close(); realChain.eventListener() .requestBodyEnd(realChain.call(), requestBodyOut.successfulCount); } else if (!connection.isMultiplexed()) { // If the \"Expect: 100-continue\" expectation wasn't met, prevent the HTTP/1 connection // from being reused. Otherwise we're still obligated to transmit the request body to // leave the connection in a consistent state. streamAllocation.noNewStreams(); } （todo 理解什么是多路复用） 结束请求 httpCodec.finishRequest(); 内部调用 @Override public void finishRequest() throws IOException { sink.flush(); } 读取响应头信息 if (responseBuilder == null) { realChain.eventListener().responseHeadersStart(realChain.call()); responseBuilder = httpCodec.readResponseHeaders(false); } 内部调用readHeaders() /** Reads headers or trailers. */ public Headers readHeaders() throws IOException { Headers.Builder headers = new Headers.Builder(); // parse the result headers until the first blank line for (String line; (line = source.readUtf8LineStrict()).length() != 0; ) { Internal.instance.addLenient(headers, line); } return headers.build(); } 构建响应 写入请求，握手情况，请求时间，以及收到响应时间 Response response = responseBuilder .request(request) .handshake(streamAllocation.connection().handshake()) .sentRequestAtMillis(sentRequestMillis) .receivedResponseAtMillis(System.currentTimeMillis()) .build(); 是否是webSock 根据状态码不同写入不同body if (forWebSocket && code == 101) { // Connection is upgrading, but we need to ensure interceptors see a non-null response body. response = response.newBuilder() .body(Util.EMPTY_RESPONSE) .build(); } else { response = response.newBuilder() .body(httpCodec.openResponseBody(response)) .build(); } 进行断开操作 coloe if (\"close\".equalsIgnoreCase(response.request().header(\"Connection\")) || \"close\".equalsIgnoreCase(response.header(\"Connection\"))) { streamAllocation.noNewStreams(); } 对204，205进行处理 抛出异常 if ((code == 204 || code == 205) && response.body().contentLength() > 0) { throw new ProtocolException( \"HTTP \" + code + \" had non-zero Content-Length: \" + response.body().contentLength()); } Copyright © david 2019 all right reserved，powered by Gitbook该文件修订时间： 2020-04-28 15:11:27 "},"Android-old/Retrofit 学习笔记.html":{"url":"Android-old/Retrofit 学习笔记.html","title":"Retrofit 学习笔记","keywords":"","body":"Retrofit 学习笔记 前言 Retrofit是个极其优秀的库,特别是和rxjava结合起来，使用起来那是一个丝滑般爽。不过使用了一两年，现在才好好想起总结总结，下面直接用实际项目中的部分代码来进行分析Retrofit帮我们做了什么。 简单的使用 创建Retrofit Retrofit.Builder().baseUrl(BuildConfig.HOST) .client(OKHTTP_CLIENT_NO_TOKEN) .addConverterFactory(GsonConverterFactory.create()) .addCallAdapterFactory(RxJava2CallAdapterFactory.create()) .build() 创建含有网络请求信息的ApiService 获取ApiService fun getApiService(): ApiService = RETROFIT.create(ApiService::class.java) 调用ApiService 接口方法 Builder 过程 Retrofit 通过 Builder 模式创建： 先来直接看 Builder.build方法： public Retrofit build() { if (baseUrl == null) { throw new IllegalStateException(\"Base URL required.\"); } okhttp3.Call.Factory callFactory = this.callFactory; if (callFactory == null) { callFactory = new OkHttpClient(); } Executor callbackExecutor = this.callbackExecutor; if (callbackExecutor == null) { callbackExecutor = platform.defaultCallbackExecutor(); } // Make a defensive copy of the adapters and add the default Call adapter. List adapterFactories = new ArrayList<>(this.adapterFactories); adapterFactories.add(platform.defaultCallAdapterFactory(callbackExecutor)); // Make a defensive copy of the converters. List converterFactories = new ArrayList<>(this.converterFactories); return new Retrofit(callFactory, baseUrl, converterFactories, adapterFactories, callbackExecutor, validateEagerly); } 这是标准的build函数，检测一些可配置参数，没有设置就是赋默认值，然后创建目标对象。 创建Retrofit对象6个参数 这里创建Retrofit需要6个参数： 1. callFactory：okhttp3.Call.Factory 这里是我们传入的OkHttpClient 对象，如果我们没有传入，build方法会为我们创建一个默认的OkhttpClient对象。 2. baseUrl：HttpUrl 我们传入host字符串后会经过HttpUrl.parse(baseUrl);处理后转换为HttpUrl对象。 3. converterFactories：List Converter.Factory 是什么？。 CallAdapter.Factory是个抽象类： 里面有三个方法： responseBodyConverter（）返回Converter对象（负责把ResponseBody对象转为其他对象） requestBodyConverter（）返回Converter对象（负责把其他对象转为RequestBody） stringConverter（）返回Converter对象（把其他对象转为String对象） 其中Converter对象是个转换接口，里面convert方法，负责把F转换为T对象。 converterFactories 里面有哪些对象？ BuiltInConverters 对象 在builder的构造方法里面创建了BuiltInConverters对象并添加到集合里面 Builder(Platform platform) { this.platform = platform; // Add the built-in converter factory first. This prevents overriding its behavior but also // ensures correct behavior when using converters that consume all types. converterFactories.add(new BuiltInConverters()); } GsonConverterFactory 对象 在上面配置中我们添加了GsonConverterFactory.create() 实际是GsonConverterFactory 对象 4. adapterFactories：List CallAdapter.Factory 是什么？ 一个抽象类，里面也是3个方法 a. get():CallAdapter 返回一个CallAdapter 适配器对象（有两个方法，一返回Type，二把Call转为其他对象的adapter方法） b. getParameterUpperBound（） ：Type 返回参数上限类型 c. getRawType 获取原始类型 adapterFactories里面对象是什么？ a. RxJava2CallAdapterFactory 对象 在前面配置中.addCallAdapterFactory(RxJava2CallAdapterFactory.create())实际是RxJava2CallAdapterFactory对象 b. ExecutorCallAdapterFactory 对象 在build方法中会执行adapterFactories.add(platform.defaultCallAdapterFactory(callbackExecutor)); ，里面实际创建的是ExecutorCallAdapterFactory对象。 5. callbackExecutor：Executor 回调执行者。 Executor callbackExecutor = this.callbackExecutor; if (callbackExecutor == null) { callbackExecutor = platform.defaultCallbackExecutor(); } 而platform变量在builder构造方法中被初始化，Android平台下是Android对象，而platform.defaultCallbackExecutor();获得的是MainThreadExecutor对象 static class Android extends Platform { @Override public Executor defaultCallbackExecutor() { return new MainThreadExecutor(); } @Override CallAdapter.Factory defaultCallAdapterFactory(Executor callbackExecutor) { return new ExecutorCallAdapterFactory(callbackExecutor); } static class MainThreadExecutor implements Executor { private final Handler handler = new Handler(Looper.getMainLooper()); @Override public void execute(Runnable r) { handler.post(r); } } } } 6. validateEagerly：boolean 默认为false create 方法做了什么 在刚开始用Retrofit时候一直很好奇，我们创建ApiService接口，没有创建任何实现对象，经过Create方法就可以直接调用接口的方法。 它这个方法里面做了什么呢。 来看下create的代码： public T create(final Class service) { //验证是否是接口 Utils.validateServiceInterface(service); //前面传入的参数，为false if (validateEagerly) { // 如果为true，会执行eagerlyValidateMethods方法， //里面会遍历接口的方法，创建对应的ServiceMethod对象并加到换成中 eagerlyValidateMethods(service); } // 关键点！！！创建动态代理对象 return (T) Proxy.newProxyInstance(service.getClassLoader(), new Class[] { service }, new InvocationHandler() { private final Platform platform = Platform.get(); @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable { // If the method is a method from Object then defer to normal invocation. if (method.getDeclaringClass() == Object.class) { return method.invoke(this, args); } if (platform.isDefaultMethod(method)) { return platform.invokeDefaultMethod(method, service, proxy, args); } ServiceMethod serviceMethod = (ServiceMethod) loadServiceMethod(method); OkHttpCall okHttpCall = new OkHttpCall<>(serviceMethod, args); return serviceMethod.callAdapter.adapt(okHttpCall); } }); } 这个方法主要分3部分，第一部分验证传入的class是否是接口，第二部分根据builder中参数是否预先创建ServiceMethod对象，而第三部分是最为重要的，创建动态代理对象。 动态代理Proxy 理解动态代理的同学，这部分可以跳过。。。。 简单的介绍下动态代理，利用反射技术在运行时候创建给定接口的动态代理对象实例。而创建这种代理对象也很简单， Proxy.newProxyInstance() 里面接受3个参数： ClassLoader 类加载器 Class[] interfaces 接口class 数组 InvocationHandler 接口。 invoke 方法有3个参数： proxy：Object 动态代理对象，可用来获取类信息，方法，annotation等 method：Method 被代用的方法，可获取方法名，参数，返回类型等信息 args：Object[] 方法参数 而动态代理类的方法都会交给实现了InvocationHandler接口对象的invoke（）处理。所以我们使用Retrofit创建了ApiService 代理对象。然后调用里面的方法时候其实是调用invoke方法 Retrofit中create方法内InvocationHandler对象的invoke方法 上面我们已经搞起动态代理是什么东西，而Retrofit之所以能帮我们实现接口定义的方法就是因为这里面的invoke。 @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable { // If the method is a method from Object then defer to normal invocation. if (method.getDeclaringClass() == Object.class) { return method.invoke(this, args); } if (platform.isDefaultMethod(method)) { return platform.invokeDefaultMethod(method, service, proxy, args); } ServiceMethod serviceMethod = (ServiceMethod) loadServiceMethod(method); OkHttpCall okHttpCall = new OkHttpCall<>(serviceMethod, args); return serviceMethod.callAdapter.adapt(okHttpCall); } 前面两个判断是保证后面的执行的我们定义的方法。后面才是重点， 这里也分了3个步骤： 根据method 加载得到ServiceMethod 创建 OkHttpCall 对象。 调用 serviceMethod.callAdapter.adapt(okHttpCall) ServiceMethod 是什么？ ServiceMethod 其实是个适配器，把我们接口定义的方法转为 http call。 里面除了一个Builder类还有3个重要的方法： toRequest（）:Request 生成请求 toResponse():Response 生成响应 parsePathParameters():Set 解析路径参数 先来看下serviceMethod怎么得到的，在invoke中调用了loadServiceMethod方法 ServiceMethod loadServiceMethod(Method method) { ServiceMethod result = serviceMethodCache.get(method); if (result != null) return result; synchronized (serviceMethodCache) { result = serviceMethodCache.get(method); if (result == null) { result = new ServiceMethod.Builder<>(this, method).build(); serviceMethodCache.put(method, result); } } return result; } 上面可看到，如果缓存中有就直接使用，没有就通过new ServiceMethod.Builder<>(this, method).build();创建。 ServiceMethod 的创建 先来分析下ServiceMethod的创建过程，上文知道先创建Builder对象然后调用build方法。 Builder构造 Builder(Retrofit retrofit, Method method) { this.retrofit = retrofit; this.method = method; this.methodAnnotations = method.getAnnotations(); this.parameterTypes = method.getGenericParameterTypes(); this.parameterAnnotationsArray = method.getParameterAnnotations(); } 这个构造方法做的事情比较简单，就五个成员变量赋值，分别是Retrofit对象，方法对象，方法注解，参数类型，参数注解（二维数组） build 方法 这个方法比较长，我们省略一些异常步骤： public ServiceMethod build() { // 获取callAdapter callAdapter = createCallAdapter(); // 获取相应类型 responseType = callAdapter.responseType(); if (responseType == Response.class || responseType == okhttp3.Response.class) { throw methodError(\"'\" + Utils.getRawType(responseType).getName() + \"' is not a valid response body type. Did you mean ResponseBody?\"); } // 赋值响应转换器 responseConverter = createResponseConverter(); // 解析方法注解 for (Annotation annotation : methodAnnotations) { parseMethodAnnotation(annotation); } ... 确保请求方式，请求体等信息正确 ... // 方法参数数量 int parameterCount = parameterAnnotationsArray.length; // 参数交给 ParameterHandler处理 parameterHandlers = new ParameterHandler[parameterCount]; for (int p = 0; p (this); } 来大概过一下这个build方法，先获取callAdapter->再通过Retrofit获取Converter转换器->解析方法注解获取请求方式->解析方法参数获取请求参数->构成ServiceMethod对象。 2.1 callAdapter 是什么对象？ createCallAdapter方法内最终通过(CallAdapter) retrofit.callAdapter(returnType, annotations);获取callAdapter对象，最终调用Retrofit的nextCallAdapter方法： public CallAdapter nextCallAdapter(CallAdapter.Factory skipPast, Type returnType, Annotation[] annotations) { checkNotNull(returnType, \"returnType == null\"); checkNotNull(annotations, \"annotations == null\"); //skipPast = null 所以是-1+1 = 0 int start = adapterFactories.indexOf(skipPast) + 1; for (int i = start, count = adapterFactories.size(); i adapter = adapterFactories.get(i).get(returnType, annotations, this); if (adapter != null) { return adapter; } } 这里会返回adapterFactories集合中第一个适配器工厂类返回的适配器，RxJava2CallAdapterFactory（如果没有添加rxjava那就是默认的工厂类 ExecutorCallAdapterFactory 类），查看RxJava2CallAdapterFactory对象的get方法，发现返回的是RxJava2CallAdapter对象。 所以callAdapter是RxJava2CallAdapter对象（如果没添加rxjava，使用默认，这个对象是CallAdapter匿名子类）。 2.2 responseConverter 是什么对象？ 同样ServiceMethod的 createResponseConverter 方法最终会调用 Retrofit的responseBodyConverter方法 retrofit.responseBodyConverter(responseType, annotations); 最终调用nextResponseBodyConverter方法： public Converter nextResponseBodyConverter(Converter.Factory skipPast, Type type, Annotation[] annotations) { checkNotNull(type, \"type == null\"); checkNotNull(annotations, \"annotations == null\"); int start = converterFactories.indexOf(skipPast) + 1; for (int i = start, count = converterFactories.size(); i converter = converterFactories.get(i).responseBodyConverter(type, annotations, this); if (converter != null) { //noinspection unchecked return (Converter) converter; } } .... .... } 这里的逻辑和nextCallAdapter类似，不过converterFactories中的第一个对象是BuiltInConverters，它的responseBodyConverter方法当方法返回类型不是ResponseBody或Void时候返回空的Converter对象。 public Converter responseBodyConverter(Type type, Annotation[] annotations, Retrofit retrofit) { if (type == ResponseBody.class) { return Utils.isAnnotationPresent(annotations, Streaming.class) ? StreamingResponseBodyConverter.INSTANCE : BufferingResponseBodyConverter.INSTANCE; } if (type == Void.class) { return VoidResponseBodyConverter.INSTANCE; } return null; } 所以我们看下GsonConverterFactory ： @Override public Converter responseBodyConverter(Type type, Annotation[] annotations, Retrofit retrofit) { TypeAdapter adapter = gson.getAdapter(TypeToken.get(type)); return new GsonResponseBodyConverter<>(gson, adapter); } 所以我们等下用GsonResponseBodyConverter分析。 2.3 解析方法 注解 主要是parseMethodAnnotation方法： private void parseMethodAnnotation(Annotation annotation) { .... else if (annotation instanceof GET) { parseHttpMethodAndPath(\"GET\", ((GET) annotation).value(), false); } .... } 里面对不同类型注解进行处理，最终都是交给parseHttpMethodAndPath方法，我们以GET为例子。 private void parseHttpMethodAndPath(String httpMethod, String value, boolean hasBody) { ... ... this.relativeUrl = value; this.relativeUrlParamNames = parsePathParameters(value); } 其实里面是获取注解内的信息然后存储在成员变量中 2.4 解析方法参数注解 主要是生成 parameterHandler，parameterHandlers[p] = parseParameter(p, parameterType, parameterAnnotations); 而parseParameter方法最终调用parseParameterAnnotation方法生成 ParameterHandler 而ParameterHandler是个抽象类，不同注解有不同实现 OkHttpCall 对象 构造器里面接受ServiceMethod 与 方法参数 RxJava2CallAdapter 的 adapter 方法 最后create方法返回的是serviceMethod.callAdapter.adapt(okHttpCall) 对象 @Override public Object adapt(Call call) { Observable> responseObservable = isAsync ? new CallEnqueueObservable<>(call) : new CallExecuteObservable<>(call); Observable observable; if (isResult) { observable = new ResultObservable<>(responseObservable); } else if (isBody) { observable = new BodyObservable<>(responseObservable); } else { observable = responseObservable; } if (scheduler != null) { observable = observable.subscribeOn(scheduler); } if (isFlowable) { return observable.toFlowable(BackpressureStrategy.LATEST); } if (isSingle) { return observable.singleOrError(); } if (isMaybe) { return observable.singleElement(); } if (isCompletable) { return observable.ignoreElements(); } return observable; } 这里返回不同的Rx 被观察者对象 ，我们以CallExecuteObservable为例看看里面怎么执行的 CallExecuteObservable 订阅方法 熟悉Rxjava的同学都知道，当Observable被订阅时候，会执行Observable的subscribeActual方法，我先来看下CallExecuteObservable的subscribeActual方法： @Override protected void subscribeActual(Observer> observer) { // Since Call is a one-shot type, clone it for each new observer. // okhttpCall 对象 Call call = originalCall.clone(); observer.onSubscribe(new CallDisposable(call)); boolean terminated = false; try { // 重要步骤，发送网络请求获取响应 Response response = call.execute(); if (!call.isCanceled()) { observer.onNext(response); } if (!call.isCanceled()) { terminated = true; observer.onComplete(); } } catch (Throwable t) { Exceptions.throwIfFatal(t); if (terminated) { RxJavaPlugins.onError(t); } else if (!call.isCanceled()) { try { observer.onError(t); } catch (Throwable inner) { Exceptions.throwIfFatal(inner); RxJavaPlugins.onError(new CompositeException(t, inner)); } } } } 可以看到里面有个重要的步骤Response response = call.execute(); 通过OkhttpCall的execute方法获取响应然后进行后面Rx的onNext等步骤。 OkhttpCall 的execute 方法 来看下实际执行网络请求： @Override public Response execute() throws IOException { okhttp3.Call call; synchronized (this) { if (executed) throw new IllegalStateException(\"Already executed.\"); executed = true; if (creationFailure != null) { if (creationFailure instanceof IOException) { throw (IOException) creationFailure; } else { throw (RuntimeException) creationFailure; } } call = rawCall; if (call == null) { try { call = rawCall = createRawCall(); } catch (IOException | RuntimeException e) { creationFailure = e; throw e; } } } if (canceled) { call.cancel(); } return parseResponse(call.execute()); } 可以看到里面其实分3个工作： 创建Okhttp3.Call 执行execute获取响应 执行parseResponse 转换响应 而其中execute获取响应是调用Okhttp中的方法，所以我们来分析下其他两个步骤： createRawCall 得到okhttp.Call private okhttp3.Call createRawCall() throws IOException { // 获取请求 Request request = serviceMethod.toRequest(args); // 其实是OkhttpClient.newCall()方法 okhttp3.Call call = serviceMethod.callFactory.newCall(request); if (call == null) { throw new NullPointerException(\"Call.Factory returned null.\"); } return call; } 终于看见关键步骤了，这方法里先通过serviceMethod 获取请求，而service.callFactory是调用Retrofit中的callFactory，也就是我们build中传入的OkhttpClient对象，所以其实Retrofit还是通过Okhttp进行网络请求。 执行parseResponse 前面已经获取了原始的响应了，怎么获取 Response parseResponse(okhttp3.Response rawResponse) throws IOException { ResponseBody rawBody = rawResponse.body(); // Remove the body's source (the only stateful object) so we can pass the response along. // 让响应source可传递 rawResponse = rawResponse.newBuilder() .body(new NoContentResponseBody(rawBody.contentType(), rawBody.contentLength())) .build(); // 获取响应码 int code = rawResponse.code(); // 异常响应 if (code = 300) { try { // Buffer the entire body to avoid future I/O. ResponseBody bufferedBody = Utils.buffer(rawBody); return Response.error(bufferedBody, rawResponse); } finally { rawBody.close(); } } // 204,205 响应成功，无数据 if (code == 204 || code == 205) { rawBody.close(); return Response.success(null, rawResponse); } ExceptionCatchingRequestBody catchingBody = new ExceptionCatchingRequestBody(rawBody); try { // 获取响应，把响应体的包装类通过serviceMethod处理 T body = serviceMethod.toResponse(catchingBody); return Response.success(body, rawResponse); } catch (RuntimeException e) { // If the underlying source threw an exception, propagate that rather than indicating it was // a runtime exception. catchingBody.throwIfCaught(); throw e; } } 上面分析可以看到原始的响应体经过serviceMethod.toResponse(catchingBody);处理变成我们想要的数据。然后把得到的数据包装成Response（并非ok中的Response）对象。 而ServiceMethod中的toResponse也很简单： R toResponse(ResponseBody body) throws IOException { return responseConverter.convert(body); } 而responseConverter对象在之前分析了是GsonResponseBodyConverter,所以我们看下它的convert方法： @Override public T convert(ResponseBody value) throws IOException { JsonReader jsonReader = gson.newJsonReader(value.charStream()); try { return adapter.read(jsonReader); } finally { value.close(); } } 这就是可以得到们要想对bean类的原因。 总结 至此，我们Retrofit的流程分析的差不多了。现在来总结下流程： 通过Retrofit.Builder 生成Retrofit对象（主要传入，baseUrl，OkhttpClient，coverter，callAdapter等）。 调用create方法得到接口的代理对象。 执行接口的某个方法触发代理对象的invoke方法。 通过Builder模式，生成 ServiceMethod 对象(期间，进行变量赋值，解析方法中注解path，解析请求参数等信息) 生成OkhttpCall 对象 执行callAdapter 中的 adapter 方法（后续以RxJava2CallAdapter为例） 生成XXXObservable等被观察者对象（后续以CallExecuteObservable为例） 下游订阅执行 subscribeActual 方法 执行OkhttpCall方法生成响应（期间使用serviceMethod生成Okhttp的Request，经过Okhttpclien得到call对象，然后生成原始Response，然后使用serviceMethod中的converter转换原始响应得到Gson处理后的响应数据） 完成一次请求。 Copyright © david 2019 all right reserved，powered by Gitbook该文件修订时间： 2020-04-28 15:11:45 "},"Android-old/Set集合源码学习.html":{"url":"Android-old/Set集合源码学习.html","title":"Set 集合源码","keywords":"","body":"Set 集合源码 Set集合简介 Set 和List都继承Collection ,从接口中定义的方法都可看出，List存放的元素有顺序，而Set存放的元素没有索引，无顺序。这也导致Set集合不能存放相同元素（无法区分）。 Set 实现类 HashSet Copyright © david 2019 all right reserved，powered by Gitbook该文件修订时间： 2020-04-28 15:07:46 "},"Android-old/沉浸式状态栏.html":{"url":"Android-old/沉浸式状态栏.html","title":"沉浸式状态栏","keywords":"","body":"沉浸式状态栏 参考 https://www.jianshu.com/p/a44c119d6ef7 原生5.0以后: ` Window window = getWindow(); window.clearFlags(WindowManager.LayoutParams.FLAG_TRANSLUCENT_STATUS); window.getDecorView().setSystemUiVisibility(View.SYSTEM_UI_FLAG_LAYOUT_FULLSCREEN | View.SYSTEM_UI_FLAG_LAYOUT_STABLE); window.addFlags(WindowManager.LayoutParams.FLAG_DRAWS_SYSTEM_BAR_BACKGROUNDS); window.setStatusBarColor(Color.TRANSPARENT);` todo: 弄清这个方法和QMUI(QMUIStatusBarHelper.translucent())原理的不同 Copyright © david 2019 all right reserved，powered by Gitbook该文件修订时间： 2020-04-28 15:08:08 "},"machine/1-机器学习学习笔记--基础.html":{"url":"machine/1-机器学习学习笔记--基础.html","title":"机器学习笔记-基础","keywords":"","body":"机器学习笔记-基础 机器学习最简要素 机器学习包含不同的方法,但其中的要素主要有: 数据 模型(转换数据) 损失函数(衡量模型好坏) 算法(最小化损失函数) 数据(Data) 数据是深度学习的核心,数据的例子包括: 图片,文本,声音,影像,结构化数据 模型(Model) 能够把数据特征转为输出结果的抽象模型 损失函数(Loss Function) 衡量模型的输出和真实值得误差.主要有两项数据衡量: 训练误差(training error):该模型在训练数据集上的误差.如同模拟考试的分数,不能保证真实考试 测试误差(test error):该模型在新数据上的误差(过拟合). 优化算法(optimization algorithm) 对参数进行搜索逐渐最小化损失.如:梯度下降法 机器学习应用分类 监督学习(Supervised Learing) 适用任务:给定输入x---->训练模型(有标注x,y)---->预测输出y 统计角度上,监督学习主要是如何估计条件概率P(y|x) 如:给定英文句子,预测它的正确中文翻译;给定财务报表,预测下个月的股票价格. \"根据输入预测结果\" (样本输入-->标注)-->训练集--->监督学习算法--->学得模型(用于预测未测试的数据) 回归分析(Regression) 特点: 输出是连续的数值 例子: 预测房价 抽取特征向量(面积,卧室数量,卫生间数量,市中心距离)-->[100,4,2,200]-->xi--->X(特征向量集合) 目标(结果)-->yi-->y(结果集合) 当目标是某个范围的任意实数时候,这个就是回归分析问题,预测标为 y^iy^i 分类(Classification) 特点:预测输出是离散的 例子：图片识别 最简单的分类问题为二分类（binary classification），训练一个能够绝对输出绝对分类的模型是很困难，一般用概率去描述。 分类问题的损失函数成为交叉熵 分类问题的一个变体,层次分类 标注(Tagging) 特点:非互斥分类,也为多标签分类 例子:文章标签 搜索与排序(Search and Ranking) 例子:信息检索领域 推荐系统(Recommender Systems) 特点:强调每个用户个性化需求 例子:电影推荐(科幻粉,文艺粉),购物网站 序列学习(Sequence Learning) 特点:输出或者输入为任意长度序列 例子:语言翻译模型 词类标注和句法分析(Tagging and Parsing) 语音识别(Automatic Speeck Recognition) 文本转语言(Text to Speech) 机器翻译(Machine Translation) 无监督学习(UNsupervised Learning) 聚类(clustering) 少量的原型-->概括数据 如:一堆照片--->分成风景/狗/婴儿 一堆用户浏览记录-->典型用户 子空间估计,主成分肥西 少量参数-->数据相关属性 如:球的轨迹-->速度,半径,质量 表征学习 与环境因素交互 学习过程中,算法与环境断开称为离线学习 强化学习(Reinforcement Learning) 对抗学习 马尔科夫决策过程 Copyright © david 2019 all right reserved，powered by Gitbook该文件修订时间： 2020-04-28 15:02:22 "},"machine/2- 机器学习学习笔记--autograd自动求导.html":{"url":"machine/2- 机器学习学习笔记--autograd自动求导.html","title":"机器学习笔记-autograd自动求导","keywords":"","body":"机器学习笔记-autograd自动求导 用途: 计算梯度,用于梯度下降中 `import mxnet.ndarray as nd` `import mxnet.autograd as ag` 为变量附上梯度 如:对函数 f=2*x² 求关于 x 的导数。我们先创建变量x，并赋初值。 `x=nd.array([[1,2],[3,4])` --> 存放x的导数,attach_grad()方法 `x.attach_grad()` --> 定义f 使用record函数 with ag.record(): y = x * 2 z = y * x --> 使用backward()进行求导。如果z不是一个标量（只有大小没有方向），那么z.backward（）等价于nd.sum(z).backward() z.backward() --> 结果 x.grad 总结: 1,输入.attach_grad 申请缓存区 2,ag.record 记录函数操作 3,f.backward() 求导 4,a.grad 获取结果 NDArray 部分api讲解 sum mxnet.ndarray.sum(data=None, axis=_Null, keepdims=_Null, exclude=_Null, out=None, name=None, **kwargs) 求总和 Example: data = [[[1,2],[2,3],[1,3]], [[1,4],[4,3],[5,2]], [[7,1],[7,2],[7,3]]] sum(data, axis=1) [[ 4. 8.] [ 10. 9.] [ 21. 6.]] sum(data, axis=[1,2]) [ 12. 19. 27.] norm norm则表示范数，首先需要注意的是范数是对向量（或者矩阵）的度量，是一个标量（scalar）： http://blog.csdn.net/lanchunhui/article/details/51004387 asscalar() 返回这个数组的标量 对控制流求导 Copyright © david 2019 all right reserved，powered by Gitbook该文件修订时间： 2020-04-28 15:03:21 "},"machine/3- 机器学习学习笔记--NDArray处理数据.html":{"url":"machine/3- 机器学习学习笔记--NDArray处理数据.html","title":"机器学习笔记-NDArray处理数据","keywords":"","body":"机器学习笔记-NDArray处理数据 处理数据:数据的读取,数据在内存中如何处理 NDArray 数据存储/变化工具,类同Numpy,支持CPU/GPU 异步计算,自动求导. 创建矩阵(数组) `form mxnet import ndarray as nd`` 创建空矩阵: nd.zeros((3,4)) 输出: [[ 0. 0. 0. 0.] [ 0. 0. 0. 0.] [ 0. 0. 0. 0.]] 创建初始值为1的数组 nd.ones((3,4) 从数组构造 nd.array([[1,2],[2,3]]) 创建随机数组 nd.random_normal(0,1,shape=(3,4)) 数组形状 y.shape 数组大小 y.size 操作符 支持数学操作符 x+y x*y nd.exp(y)指数 矩阵转置y.T广播 当二元操作符两边的形状不一样时候.系统会复制到同一个形状.与NumPy 的转换 import numpy as np x = np.ones((2,3)) y = nd.array(x) # numpy -> mxnet z = y.asnumpy() # mxnet -> numpy print([z, y]) 替换操作 目的节省内存空间 可以把结果通过[:]写到之前的开辟好的数组空间 如: z = nd.zeros_like(x) before = id(z) z[:] = x + y id(z) == before 截取 ` x = nd.arange(0,9).reshape((3,3)) print('x: ', x) x[1:3]` 直接写入位置 x[1,2]=9.0 多维截取 x = nd.arange(0,9).reshape((3,3)) print('x: ', x) x[1:2,1:3] 多维写入 x[1:2,1:3] = 9.0 参考:https://mxnet.incubator.apache.org/api/python/ndarray.html Copyright © david 2019 all right reserved，powered by Gitbook该文件修订时间： 2020-04-28 15:04:46 "},"machine/4-Numpy 教程.html":{"url":"machine/4-Numpy 教程.html","title":"机器学习笔记-Numpy","keywords":"","body":"机器学习笔记-Numpy 简介 作用 数组的算术和逻辑运算 傅里叶变换/图形操作的例程 线性代数相关操作。Numpy有线性代数和随机数生成的内置函数 Ndarray 对象 N 维数组类型。 它描述相同类型的元素集合。 可以使用基于零的索引访问集合中的项目。 Copyright © david 2019 all right reserved，powered by Gitbook该文件修订时间： 2020-04-28 15:05:26 "},"machine/5-机器学习笔记--矩阵.html":{"url":"machine/5-机器学习笔记--矩阵.html","title":"机器学习笔记-矩阵","keywords":"","body":"机器学习笔记-矩阵 逆矩阵 定义 设A,B都是n阶方阵,如果存在n阶方阵使得AB=BA=E,则称A为可逆矩阵,而B为A的逆矩阵. Copyright © david 2019 all right reserved，powered by Gitbook该文件修订时间： 2020-04-28 15:00:33 "},"machine/6-机器学习笔记--线性回归.html":{"url":"machine/6-机器学习笔记--线性回归.html","title":"机器学习笔记-线性回归","keywords":"","body":"机器学习笔记-线性回归 线性回归 Copyright © david 2019 all right reserved，powered by Gitbook该文件修订时间： 2020-04-28 15:01:03 "},"其他/1-Conda常用命令.html":{"url":"其他/1-Conda常用命令.html","title":"管理conda","keywords":"","body":"管理conda conda --version 查看当前版本 conda update conda 升级到当前最新版本 管理环境 创建环境 conda creat --name hehe python=2 比如我原来有Python3的环境，现在新创建一个新环境，叫hehe，里面安装python2。 环境操作 Linux, OS X: source activate hehe Windows: activate hehe 如果要更换环境，继续用上面的命令，加另外的环境名就好。 退出则使用deactivate hehe或 source deactivate hehe，退回到默认root环境中。 查看电脑中都有哪些环境：conda info --envs或conda env list，带*号的是当前所在的环境。 复制一个环境：conda create --name lala --clone hehe，复制hehe。 删除环境：conda remove --name lala --all，删除lala。 共享环境：把你的环境导出来（包括安装的包们）给别人使用，这样他可以很快搞出一个和你一样的环境，而不用一步一步的安装了。 进入到要共享的环境下activate peppermint或source activate peppermint，执行conda env export > environment.yml。如果当前环境下已经有一个.yml的文件，它会被重写的。 把这个environment.yml文件拷贝给其他人。（默认出现在你安装anaconda的文件夹下） 然后用conda env create -f environment.yml在其他电脑上创建新环境。 管理Python和package 升级Python版本： conda update python，升级到当前分支的最新版本，如果3.5.2会升级到3.5.3。 conda isntall python=3.6，这样会直接升级到3.6的最新版本。 查看已安装的包：conda list（当前环境下的），conda list -name hehe（hehe环境下的） 搜索某个特定的包：conda search beautifulsoup4 安装包：conda isntall --name envName beautifulsoup4，用--name指定安装在哪个环境下。 也可以用pip install packageName，但是不能指定环境，也不能升级Python。 升级包：conda update conda, conda update python, conda update beautifulsoup4。几乎啥都可以升级。 删除包：conda remove --name envName beautifulsoup4 参考: https://www.jianshu.com/p/d2e15200ee9b http://blog.csdn.net/menc15/article/details/71477949 Copyright © david 2019 all right reserved，powered by Gitbook该文件修订时间： 2020-04-28 14:55:51 "},"其他/2-Git学习笔记.html":{"url":"其他/2-Git学习笔记.html","title":"Git 学习笔记","keywords":"","body":"Git 学习笔记 专用名词 Workspace：工作区 Index / Stage：暂存区 Repository：仓库区（或本地仓库） Remote：远程仓库 常见命令 命令清单 新建代码库 新建一个git代码库 git init 新建一个目录,并初始化为代码库 git init [project-name] 克隆一个项目 git clone [url] 配置 Git 的配置文件为.gitconfig 当前的git配置 git config --list 设置提交代码时的用户信息 git config [--global] user.name \"[name]\" git config [--global] user.email \"[email address]\" 增/删 文件 增 添加指定文件到暂存区 git add [file1] [file2] 添加指定目录 git add [dir] 添加当前目录所有文件 git add . 删 删除工作区文件,并将这次删除放入暂存区 git rm [file1] [file2] 停止追踪指定文件，但该文件会保留在工作区 git rm --cached [file] 改名文件，并且将这个改名放入暂存区 git mv [file-original] [file-renamed] 代码提交 提交暂存区到仓库区 git commit -m [message] 提交暂存区的指定文件到仓库区 git commit [file1] [file2] [file3] ... -m [message] 提交工作区自上次commit之后的变化，直接到仓库区 git commit -a 提交时显示所有diff信息 git commit -v 使用一次新的commit，替代上一次提交(如果代码没有任何新变化，则用来改写上一次commit的提交信息) git commit --amend -m [message] 重做上一次commit，并包括指定文件的新变化 git commit --amend [file] [file2] 分支管理 本地所有分支 git branch 远程所有分支 git branch -r 本地&远程所有分支 git branch -a 新建分支 git branch [branch-name] 新建分支,并且切换到该分支 git checkout [branch-name] 新建分支,并指定远程分支建立追踪关系 git branch --track [branch] [remote-branch] 切换分支 git checkout [branch-name] 切换到上个分支 git chekout - 建立追踪关系 git branch --set-upstream [branch] [remote-branch] 合并指定分支到当前分支 git merge [branch] 删除分支 git branch -d [branch-name] 删除远程分支 git branch -dr [branch-name] git push origin --delete [branch-name] 标签 列出所有tag git tag 新建一个tag在当前commit git tag [tagName] 新建一个tag在指定commit git tag [tagName] [commit] 删除本地tag git tag -d [tagName] 删除远程tag git push origin :refs/tags/[tagName] 查看tag信息 git show [tagName] 提交指定tag git push [remote] [tagName] 提交所有tag git push [remote] --tags 新建一个分支,指向某个tag git checkout -b [branch] [tag] 查看信息 显示变更文件 git status 显示当前分支的版本信息 git log 显示commit历史,以及每次commit发生变更的文件 git log --stat 搜索提交历史,根据关键词 git log -S [keyword] 显示暂存区和工作区的差异 git diff 显示今天你写了多少行代码 git diff --shortstat\"@{0 day ago}\" 显示当前分支的最近几次提交 git reflog 远程同步 下载远程仓库所有变动 git fetch [remote] 显示所有远程仓库 git remote -v 显示某个远程仓库信息 git remote show [remote] 新增一个远程仓库 git remote add [shortname] [url] 取回远程仓库编号,并且与本地分支合并 git pull [remote] [branch] 上传本地分支到远程仓库 git push [remote] [branch] 强行推送当前分支到远程仓库,即使有冲突 git push [remote] --force 推送所有分支到远程仓库 git push [remote] --all 撤销 恢复暂存区的指定文件到工作区 git checkout [file] 恢复暂存区的所有文件到工作区 git checkout . Copyright © david 2019 all right reserved，powered by Gitbook该文件修订时间： 2020-04-28 14:57:04 "},"其他/3-UML类图.html":{"url":"其他/3-UML类图.html","title":"UML 类图","keywords":"","body":"UML 类图 类的属性 在UML类图中，类使用包含类名、属性(field) 和方法(method) 且带有分割线的矩形来表示，比如下图表示一个Employee类，它包含name,age和email这3个属性，以及modifyInfo()方法。 · + ：表示public · - ：表示private · #：表示protected 实际上，属性的完整表示方式是这样的： 可见性 名称 ：类型 [ = 缺省值] 类的方法的表示方式 可见性 名称(参数列表) [ ： 返回类型] UML中的关系 依赖 Dependency 带箭头的虚线表示，箭头从使用类指向被依赖的类。 代码中一般指由局部变量、函数参数、返回值建立的对于其他对象的调用关系。 一个类调用被依赖类中的某些方法而得以完成这个类的一些职责。 虚线箭头 关联 Association 对象之间一种引用关系，比如客户类与订单类之间的关系。 这种关系通常使用类的属性表达。 关联又分为一般关联、聚合关联与组合关联。 后两种在后面分析。 在类图使用带箭头的实线表示，箭头从使用类指向被关联的类。可以是单向和双向。 实线箭头 单向关联 双向关联 双方各自持有对方类型的成员变量 自关联 自己包含自己 聚合 Aggregation 空心菱形和箭头表示 整体包含部分,部分可脱离整体单独存在 比如上图中汽车包含了发动机，而发动机脱离了汽车也能单独存在。 合成 Composition 显然，嘴是头的一部分且不能脱离了头而单独存在。在UML类图中，组合关系用一个带实心菱形和箭头的直线表示。 泛化 (继承) Generalization 实现 Realization 虚线三角 类图符号 类 长方形，由3部分组成，第一部分类名、第二部分属性、第三部分方法。 包 接口 通常使用带有名称的小圆圈表示 Copyright © david 2019 all right reserved，powered by Gitbook该文件修订时间： 2020-04-28 14:57:36 "}}